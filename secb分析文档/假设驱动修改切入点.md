# SWE-agent å‡è®¾é©±åŠ¨ä¿®æ”¹åˆ‡å…¥ç‚¹è¯¦è§£

åŸºäº `å®Œæ•´å·¥ä½œæµåˆ†æ.md` çš„æ¶æ„åˆ†æï¼Œç²¾ç¡®å®šä½å‡è®¾ç®¡ç†ã€åˆ†æ”¯åˆ‡æ¢çš„å®ç°ä½ç½®ã€‚

---

## æ ¸å¿ƒæ‰§è¡Œæµå›é¡¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. run_secb.sh                                              â”‚
â”‚    â†“ è°ƒç”¨                                                   â”‚
â”‚ 2. sweagent run-batch                                       â”‚
â”‚    â†“ åŠ è½½é…ç½®                                               â”‚
â”‚ 3. config/secb_poc.yaml (AgentConfig)                      â”‚
â”‚    â†“ æ‰¹é‡å¤„ç†                                               â”‚
â”‚ 4. run_single_instance(instance, config)                   â”‚
â”‚    â”œâ”€ åˆ›å»º SWEEnv(instance, config)                        â”‚
â”‚    â”œâ”€ åˆå§‹åŒ– Agent(config.agent)                           â”‚
â”‚    â””â”€ agent.run(env, instance)  â† æ ¸å¿ƒå¾ªç¯                 â”‚
â”‚       â†“                                                      â”‚
â”‚ 5. Agent æ‰§è¡Œå¾ªç¯ (æœ€å¤š 75 æ¬¡è¿­ä»£)                          â”‚
â”‚    Loop:                                                     â”‚
â”‚      â”œâ”€ æ¸²æŸ“ prompt (system + history + observation)       â”‚
â”‚      â”œâ”€ è°ƒç”¨ LLM ç”Ÿæˆ action (JSON)                        â”‚
â”‚      â”œâ”€ è§£æ action                                         â”‚
â”‚      â”œâ”€ åœ¨å®¹å™¨ä¸­æ‰§è¡Œ action                                 â”‚
â”‚      â”œâ”€ è·å– observation                                    â”‚
â”‚      â””â”€ æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶ (submit æˆ–é™åˆ¶)                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ä¿®æ”¹åˆ‡å…¥ç‚¹ 1ï¼šAgentConfig æ‰©å±• â­â­â­

**ä½ç½®**ï¼š`sweagent/agent/agents.py` å’Œ `sweagent/run/run_single.py`

**ç›®æ ‡**ï¼šåœ¨ Agent åˆå§‹åŒ–æ—¶æ³¨å…¥å‡è®¾ç®¡ç†å™¨

### å½“å‰ä»£ç ç»“æ„

```python
# sweagent/run/run_single.py
class RunSingleConfig(BaseSettings):
    instances: InstanceSourceConfig
    agent: AgentConfig  # â† è¿™æ˜¯ Agent é…ç½®
    output_dir: Path
    # ...

def run_single():
    config = RunSingleConfig.from_yaml(...)

    # åˆ›å»ºç¯å¢ƒ
    env = SWEEnv(instance, config)

    # åˆ›å»º Agent
    agent = get_agent_from_config(config.agent)  # â† å…³é”®å‡½æ•°

    # è¿è¡Œ Agent
    result = agent.run(env, instance)
```

### ä¿®æ”¹æ–¹æ¡ˆ Aï¼šæ‰©å±• AgentConfig

```python
# sweagent/agent/agents.py (æ–°å¢)
from dataclasses import dataclass, field
from typing import Optional

@dataclass
class HypothesisConfig:
    """å‡è®¾é©±åŠ¨é…ç½®"""
    enabled: bool = True
    phase0_service_url: str = "http://localhost:5000"
    auto_switch_on_deadend: bool = True
    deadend_threshold: int = 5
    max_iterations_per_hypothesis: int = 30

    # çŸ›ç›¾æ£€æµ‹å…³é”®è¯
    contradiction_keywords: list[str] = field(default_factory=lambda: [
        "å·²åˆå§‹åŒ–", "å­˜åœ¨æ£€æŸ¥", "ä¸å¯èƒ½è§¦å‘"
    ])

@dataclass
class AgentConfig(BaseSettings):
    # åŸæœ‰å­—æ®µ
    templates: TemplateConfig
    model: ModelConfig
    tools: ToolsConfig
    history_processors: list[HistoryProcessorConfig]

    # â­ æ–°å¢å­—æ®µ
    hypothesis_config: Optional[HypothesisConfig] = None
```

### ä¿®æ”¹æ–¹æ¡ˆ Bï¼šåˆ›å»º HypothesisAwareAgent

```python
# sweagent/agent/hypothesis_agent.py (æ–°æ–‡ä»¶)
from sweagent.agent.agents import Agent
from sweagent.state.hypothesis_orchestrator import HypothesisOrchestrator

class HypothesisAwareAgent(Agent):
    """å‡è®¾é©±åŠ¨çš„ Agent"""

    def __init__(self, config: AgentConfig, hypothesis_orchestrator: HypothesisOrchestrator):
        super().__init__(config)
        self.hypothesis_orchestrator = hypothesis_orchestrator
        self.verification_tracker = VerificationTracker()
        self.contradiction_detector = ContradictionDetector(hypothesis_orchestrator)
        self.deadend_detector = DeadendDetector()

    def run(self, env: SWEEnv, instance: Any):
        """æ‰©å±•çš„æ‰§è¡Œå¾ªç¯"""
        # 1. åˆå§‹åŒ–å‡è®¾çŠ¶æ€
        self._initialize_hypotheses(env, instance)

        # 2. ä¸»å¾ªç¯
        for iteration in range(self.config.model.per_instance_call_limit):
            # 2.1 è·å–å½“å‰å‡è®¾
            current_hypothesis = self.hypothesis_orchestrator.get_active_hypothesis()

            # 2.2 æ„é€  promptï¼ˆæ³¨å…¥å‡è®¾ä¸Šä¸‹æ–‡ï¼‰
            prompt = self._build_prompt_with_hypothesis(
                env=env,
                hypothesis=current_hypothesis,
                iteration=iteration
            )

            # 2.3 ç”Ÿæˆ action
            action = self._generate_action(prompt)

            # 2.4 æ‰§è¡Œ action
            observation = self._execute_action(action, env)

            # 2.5 æ›´æ–°çŠ¶æ€
            self._update_state(action, observation, current_hypothesis)

            # 2.6 æ£€æµ‹éªŒè¯ç»“æœ
            result = self._detect_verification_result(observation, current_hypothesis)

            if result == VerificationResult.POC_SUCCESS:
                return self._handle_success(current_hypothesis)
            elif result == VerificationResult.CONTRADICTION:
                self._handle_contradiction(observation, current_hypothesis)
            elif result == VerificationResult.DEADEND:
                self._handle_deadend(current_hypothesis)

            # 2.7 æ£€æŸ¥ç»ˆæ­¢æ¡ä»¶
            if self._should_terminate(observation):
                break

        return self._finalize_result()

    def _initialize_hypotheses(self, env, instance):
        """Phase 0: åˆå§‹åŒ–å‡è®¾"""
        # Step 1: è§£æ Sanitizer æŠ¥å‘Š
        sanitizer_info = self._parse_sanitizer_report(instance.problem_statement)

        # Step 2: è°ƒç”¨ Phase0 æœåŠ¡ç”Ÿæˆå‡è®¾
        hypotheses = self._generate_hypotheses_from_phase0(sanitizer_info)

        # Step 3: åˆå§‹åŒ– orchestrator
        self.hypothesis_orchestrator.initialize(
            hypotheses=hypotheses,
            sanitizer_info=sanitizer_info
        )

        logger.info(f"âœ… Initialized {len(hypotheses)} hypotheses")

    def _build_prompt_with_hypothesis(self, env, hypothesis, iteration):
        """æ„é€ æ³¨å…¥å‡è®¾çš„ prompt"""
        # åŸºç¡€ promptï¼ˆä»é…ç½®åŠ è½½ï¼‰
        base_prompt = self.config.templates.system_template

        # æ³¨å…¥å‡è®¾ä¸Šä¸‹æ–‡
        hypothesis_context = f"""
## Current Hypothesis (Iteration {iteration})

**ID**: {hypothesis.id}
**Description**: {hypothesis.description}
**Priority**: {hypothesis.priority}
**Expected Evidence**: {hypothesis.expected_evidence}

### Suggested Verification Steps
{self._format_suggested_steps(hypothesis.suggested_steps)}

### Verification History (This Hypothesis)
- **Attempts**: {len(self.verification_tracker.get_attempts(hypothesis.id))}
- **Consecutive Failures**: {self.verification_tracker.get_consecutive_failures(hypothesis.id)}
"""

        # æ³¨å…¥ Sanitizer Ground Truth
        sanitizer_context = f"""
## Ground Truth from Sanitizer Report

- **Error Type**: {self.hypothesis_orchestrator.sanitizer_info['error_type']}
- **Crash Location**: {self.hypothesis_orchestrator.sanitizer_info['crash_location']}
- **Crash Function**: {self.hypothesis_orchestrator.sanitizer_info['crash_function']}
- **Call Stack** (top 5):
{self._format_call_stack(self.hypothesis_orchestrator.sanitizer_info['call_stack'][:5])}
"""

        # æ³¨å…¥å·²çŸ¥å‘ç°
        discoveries_context = self._format_discoveries()

        # ç»„åˆ prompt
        full_prompt = f"""
{base_prompt}

{hypothesis_context}

{sanitizer_context}

{discoveries_context}

## ğŸ¯ CRITICAL INSTRUCTIONS

### Hypothesis Loyalty (HIGH THRESHOLD FOR SWITCHING)
Only request `hypothesis_switch` when:
1. You find direct contradictory evidence
2. You've exhausted all suggested_steps without finding expected evidence
3. PoC attempts consistently fail (5+ times)

### Next Action
Based on the current hypothesis and verification history, what's your next action?
"""

        return full_prompt

    def _detect_verification_result(self, observation, current_hypothesis):
        """æ£€æµ‹éªŒè¯ç»“æœ"""
        # 1. æ£€æµ‹ PoC æˆåŠŸ
        if self._is_poc_success(observation):
            return VerificationResult.POC_SUCCESS

        # 2. æ£€æµ‹çŸ›ç›¾
        is_contradiction, reason = self.contradiction_detector.check(
            observation, current_hypothesis
        )
        if is_contradiction:
            logger.warning(f"âš ï¸ Contradiction detected: {reason}")
            return VerificationResult.CONTRADICTION

        # 3. æ£€æµ‹æ­»è·¯
        is_deadend, reason = self.deadend_detector.check(
            hypothesis_id=current_hypothesis.id,
            tracker=self.verification_tracker
        )
        if is_deadend:
            logger.warning(f"âš ï¸ Deadend detected: {reason}")
            return VerificationResult.DEADEND

        # 4. æ­£å¸¸ç»§ç»­
        return VerificationResult.CONTINUE

    def _handle_contradiction(self, observation, current_hypothesis):
        """å¤„ç†çŸ›ç›¾ï¼šåˆ‡æ¢å‡è®¾"""
        logger.info(f"ğŸ”„ Handling contradiction, switching hypothesis...")

        # 1. æ ‡è®°å½“å‰å‡è®¾ä¸º REFUTED
        self.hypothesis_orchestrator.refute_hypothesis(
            hypothesis_id=current_hypothesis.id,
            reason=observation.contradiction_reason
        )

        # 2. æ¿€æ´» fallback å‡è®¾
        next_hypothesis = self.hypothesis_orchestrator.activate_fallback()

        if not next_hypothesis:
            logger.error("âŒ No fallback hypothesis available!")
            raise NoFallbackHypothesisError()

        # 3. æ¸…ç©ºéªŒè¯å†å²
        self.verification_tracker.clear_hypothesis_attempts(current_hypothesis.id)

        logger.info(f"âœ… Switched to hypothesis: {next_hypothesis.id}")

    def _is_poc_success(self, observation):
        """æ£€æµ‹ PoC æ˜¯å¦æˆåŠŸè§¦å‘æ¼æ´"""
        success_indicators = [
            'ERROR: AddressSanitizer',
            'SEGV on unknown address',
            'heap-use-after-free',
            'null-pointer-dereference',
            'Segmentation fault',
            'core dumped'
        ]

        message = observation.message.lower()
        return any(indicator.lower() in message for indicator in success_indicators)
```

---

## ä¿®æ”¹åˆ‡å…¥ç‚¹ 2ï¼šçŠ¶æ€ç®¡ç†ç»„ä»¶ â­â­â­

**ä½ç½®**ï¼š`sweagent/state/` (æ–°ç›®å½•)

**ç›®æ ‡**ï¼šå®ç°å‡è®¾çŠ¶æ€ç®¡ç†ã€éªŒè¯è¿½è¸ªã€çŸ›ç›¾æ£€æµ‹

### ç›®å½•ç»“æ„

```
sweagent/state/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ hypothesis_orchestrator.py     # å‡è®¾ç®¡ç†å™¨ï¼ˆæ ¸å¿ƒï¼‰
â”œâ”€â”€ verification_tracker.py        # éªŒè¯å†å²è¿½è¸ª
â”œâ”€â”€ contradiction_detector.py      # çŸ›ç›¾æ£€æµ‹
â”œâ”€â”€ deadend_detector.py           # æ­»è·¯æ£€æµ‹
â””â”€â”€ schemas.py                    # æ•°æ®ç»“æ„å®šä¹‰
```

### æ ¸å¿ƒä»£ç ï¼šhypothesis_orchestrator.py

```python
# sweagent/state/hypothesis_orchestrator.py
import json
from pathlib import Path
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, asdict
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class HypothesisStatus(Enum):
    PENDING = "pending"
    ACTIVE = "active"
    CONFIRMED = "confirmed"
    REFUTED = "refuted"
    INCONCLUSIVE = "inconclusive"

@dataclass
class Hypothesis:
    id: str
    description: str
    priority: int
    suggested_steps: List[str]
    expected_evidence: str
    status: HypothesisStatus = HypothesisStatus.PENDING
    refuted_reason: Optional[str] = None
    fallback_to: Optional[str] = None  # fallback å‡è®¾çš„ ID

class HypothesisOrchestrator:
    """å‡è®¾ç®¡ç†å™¨ - æ ¸å¿ƒçŠ¶æ€ç®¡ç†ç»„ä»¶"""

    def __init__(self, state_file: Path = Path("/workspace/.hypothesis_state.json")):
        self.state_file = state_file
        self.hypotheses: Dict[str, Hypothesis] = {}
        self.active_hypothesis_id: Optional[str] = None
        self.sanitizer_info: Dict[str, Any] = {}
        self.discoveries: List[str] = []

    def initialize(self, hypotheses: List[Dict], sanitizer_info: Dict):
        """åˆå§‹åŒ–å‡è®¾å’Œ Ground Truth"""
        # 1. ä¿å­˜ Sanitizer ä¿¡æ¯
        self.sanitizer_info = sanitizer_info

        # 2. æ„å»ºå‡è®¾å¯¹è±¡
        for hyp_data in hypotheses:
            hypothesis = Hypothesis(
                id=hyp_data['id'],
                description=hyp_data['description'],
                priority=hyp_data['priority'],
                suggested_steps=hyp_data['suggested_steps'],
                expected_evidence=hyp_data['expected_evidence'],
                status=HypothesisStatus.PENDING,
                fallback_to=hyp_data.get('fallback_to')
            )
            self.hypotheses[hypothesis.id] = hypothesis

        # 3. æ¿€æ´»æœ€é«˜ä¼˜å…ˆçº§å‡è®¾
        primary = sorted(hypotheses, key=lambda h: h['priority'])[0]
        self.activate_hypothesis(primary['id'])

        # 4. ä¿å­˜çŠ¶æ€
        self.save_state()

        logger.info(f"âœ… Initialized {len(hypotheses)} hypotheses")
        logger.info(f"âœ… Activated primary hypothesis: {primary['id']}")

    def activate_hypothesis(self, hypothesis_id: str):
        """æ¿€æ´»æŒ‡å®šå‡è®¾"""
        if hypothesis_id not in self.hypotheses:
            raise ValueError(f"Hypothesis {hypothesis_id} not found")

        # å°†å½“å‰ active å‡è®¾æ ‡è®°ä¸º pendingï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if self.active_hypothesis_id:
            current = self.hypotheses[self.active_hypothesis_id]
            if current.status == HypothesisStatus.ACTIVE:
                current.status = HypothesisStatus.PENDING

        # æ¿€æ´»æ–°å‡è®¾
        self.hypotheses[hypothesis_id].status = HypothesisStatus.ACTIVE
        self.active_hypothesis_id = hypothesis_id

        self.save_state()

    def get_active_hypothesis(self) -> Optional[Hypothesis]:
        """è·å–å½“å‰æ´»è·ƒå‡è®¾"""
        if not self.active_hypothesis_id:
            return None
        return self.hypotheses.get(self.active_hypothesis_id)

    def refute_hypothesis(self, hypothesis_id: str, reason: str):
        """æ ‡è®°å‡è®¾ä¸º REFUTED"""
        hypothesis = self.hypotheses[hypothesis_id]
        hypothesis.status = HypothesisStatus.REFUTED
        hypothesis.refuted_reason = reason

        logger.info(f"âŒ Refuted hypothesis {hypothesis_id}: {reason}")
        self.save_state()

    def confirm_hypothesis(self, hypothesis_id: str):
        """æ ‡è®°å‡è®¾ä¸º CONFIRMED"""
        hypothesis = self.hypotheses[hypothesis_id]
        hypothesis.status = HypothesisStatus.CONFIRMED

        logger.info(f"âœ… Confirmed hypothesis {hypothesis_id}")
        self.save_state()

    def activate_fallback(self) -> Optional[Hypothesis]:
        """æ¿€æ´» fallback å‡è®¾"""
        current = self.get_active_hypothesis()

        # 1. æ£€æŸ¥æ˜¯å¦æœ‰æ˜¾å¼ fallback
        if current.fallback_to:
            fallback = self.hypotheses.get(current.fallback_to)
            if fallback and fallback.status == HypothesisStatus.PENDING:
                self.activate_hypothesis(fallback.id)
                return fallback

        # 2. è‡ªåŠ¨é€‰æ‹©æœ€é«˜ä¼˜å…ˆçº§çš„ PENDING å‡è®¾
        pending = [h for h in self.hypotheses.values()
                   if h.status == HypothesisStatus.PENDING]

        if not pending:
            logger.error("âŒ No fallback hypothesis available!")
            return None

        next_hypothesis = sorted(pending, key=lambda h: h.priority)[0]
        self.activate_hypothesis(next_hypothesis.id)

        return next_hypothesis

    def add_discovery(self, discovery: str):
        """è®°å½•æ–°å‘ç°"""
        self.discoveries.append(discovery)
        self.save_state()

    def save_state(self):
        """ä¿å­˜çŠ¶æ€åˆ°æ–‡ä»¶"""
        state = {
            'hypotheses': {
                h_id: {
                    'id': h.id,
                    'description': h.description,
                    'priority': h.priority,
                    'suggested_steps': h.suggested_steps,
                    'expected_evidence': h.expected_evidence,
                    'status': h.status.value,
                    'refuted_reason': h.refuted_reason,
                    'fallback_to': h.fallback_to
                }
                for h_id, h in self.hypotheses.items()
            },
            'active_hypothesis_id': self.active_hypothesis_id,
            'sanitizer_info': self.sanitizer_info,
            'discoveries': self.discoveries
        }

        with open(self.state_file, 'w') as f:
            json.dump(state, f, indent=2)

    def load_state(self):
        """ä»æ–‡ä»¶åŠ è½½çŠ¶æ€"""
        if not self.state_file.exists():
            logger.warning(f"State file {self.state_file} not found")
            return

        with open(self.state_file, 'r') as f:
            state = json.load(f)

        # é‡å»ºå‡è®¾å¯¹è±¡
        self.hypotheses = {
            h_id: Hypothesis(
                id=h_data['id'],
                description=h_data['description'],
                priority=h_data['priority'],
                suggested_steps=h_data['suggested_steps'],
                expected_evidence=h_data['expected_evidence'],
                status=HypothesisStatus(h_data['status']),
                refuted_reason=h_data.get('refuted_reason'),
                fallback_to=h_data.get('fallback_to')
            )
            for h_id, h_data in state['hypotheses'].items()
        }

        self.active_hypothesis_id = state['active_hypothesis_id']
        self.sanitizer_info = state['sanitizer_info']
        self.discoveries = state['discoveries']
```

### éªŒè¯è¿½è¸ªå™¨ï¼šverification_tracker.py

```python
# sweagent/state/verification_tracker.py
from dataclasses import dataclass
from typing import List
import time

@dataclass
class VerificationAttempt:
    hypothesis_id: str
    action: str
    outcome: str  # 'success', 'failure', 'neutral'
    timestamp: float
    observation_summary: str

class VerificationTracker:
    """éªŒè¯å†å²è¿½è¸ª"""

    def __init__(self):
        self.attempts: List[VerificationAttempt] = []

    def record_attempt(self, hypothesis_id: str, action: str,
                       outcome: str, observation: str):
        """è®°å½•éªŒè¯å°è¯•"""
        attempt = VerificationAttempt(
            hypothesis_id=hypothesis_id,
            action=action,
            outcome=outcome,
            timestamp=time.time(),
            observation_summary=observation[:200]  # åªä¿å­˜æ‘˜è¦
        )
        self.attempts.append(attempt)

    def get_attempts(self, hypothesis_id: str) -> List[VerificationAttempt]:
        """è·å–æŒ‡å®šå‡è®¾çš„æ‰€æœ‰éªŒè¯å°è¯•"""
        return [a for a in self.attempts if a.hypothesis_id == hypothesis_id]

    def get_consecutive_failures(self, hypothesis_id: str) -> int:
        """è®¡ç®—è¿ç»­å¤±è´¥æ¬¡æ•°"""
        recent_attempts = [a for a in self.attempts[-10:]
                          if a.hypothesis_id == hypothesis_id]

        consecutive = 0
        for attempt in reversed(recent_attempts):
            if attempt.outcome == 'failure':
                consecutive += 1
            else:
                break

        return consecutive

    def get_hypothesis_iterations(self, hypothesis_id: str) -> int:
        """è·å–å‡è®¾çš„æ€»è¿­ä»£æ¬¡æ•°"""
        return len([a for a in self.attempts if a.hypothesis_id == hypothesis_id])

    def clear_hypothesis_attempts(self, hypothesis_id: str):
        """æ¸…ç©ºæŒ‡å®šå‡è®¾çš„éªŒè¯å†å²ï¼ˆåˆ‡æ¢å‡è®¾æ—¶è°ƒç”¨ï¼‰"""
        self.attempts = [a for a in self.attempts
                        if a.hypothesis_id != hypothesis_id]
```

### çŸ›ç›¾æ£€æµ‹å™¨ï¼šcontradiction_detector.py

```python
# sweagent/state/contradiction_detector.py
import re
from typing import Tuple

class ContradictionDetector:
    """çŸ›ç›¾æ£€æµ‹ - æ£€æµ‹è§‚å¯Ÿç»“æœæ˜¯å¦ä¸å‡è®¾çŸ›ç›¾"""

    def __init__(self, hypothesis_orchestrator):
        self.orchestrator = hypothesis_orchestrator

    def check(self, observation, current_hypothesis) -> Tuple[bool, str]:
        """
        æ£€æµ‹çŸ›ç›¾
        è¿”å›: (is_contradiction, reason)
        """
        message = observation.message
        hyp_desc = current_hypothesis.description.lower()

        # è§„åˆ™ 1ï¼šå‡è®¾"ç¼ºå°‘ X" â†’ å®é™…æ‰¾åˆ°äº† X
        if self._check_missing_vs_found(hyp_desc, message):
            return True, "Expected missing code was found"

        # è§„åˆ™ 2ï¼šå‡è®¾"æœªåˆå§‹åŒ–" â†’ å®é™…æ‰¾åˆ°åˆå§‹åŒ–
        if self._check_uninitialized_vs_initialized(hyp_desc, message):
            return True, "Variable is actually initialized"

        # è§„åˆ™ 3ï¼šå‡è®¾"å‡½æ•° X è§¦å‘" â†’ å‡½æ•°ä¸å¯è¾¾
        if self._check_unreachable_function(hyp_desc, message):
            return True, "Assumed trigger function is unreachable"

        return False, None

    def _check_missing_vs_found(self, hypothesis: str, observation: str) -> bool:
        """æ£€æµ‹ï¼šå‡è®¾ç¼ºå°‘ X â†’ å®é™…æ‰¾åˆ° X"""
        missing_patterns = [
            r'ç¼ºå°‘.*?(\w+)',
            r'missing\s+(\w+)',
            r'without\s+(\w+)',
            r'lacks\s+(\w+)'
        ]

        found_patterns = [
            r'æ‰¾åˆ°.*?(\w+)',
            r'found\s+(\w+)',
            r'exists\s+(\w+)',
            r'å·²å­˜åœ¨.*?(\w+)'
        ]

        # æå–å‡è®¾ä¸­å£°ç§°ç¼ºå°‘çš„å†…å®¹
        for pattern in missing_patterns:
            match = re.search(pattern, hypothesis, re.IGNORECASE)
            if match:
                missing_item = match.group(1)

                # æ£€æŸ¥è§‚å¯Ÿä¸­æ˜¯å¦å£°ç§°æ‰¾åˆ°äº†å®ƒ
                for found_pattern in found_patterns:
                    if re.search(found_pattern.replace(r'(\w+)', missing_item),
                                observation, re.IGNORECASE):
                        return True

        return False

    def _check_uninitialized_vs_initialized(self, hypothesis: str, observation: str) -> bool:
        """æ£€æµ‹ï¼šå‡è®¾æœªåˆå§‹åŒ– â†’ å®é™…å·²åˆå§‹åŒ–"""
        uninit_keywords = ['æœªåˆå§‹åŒ–', 'uninitialized', 'not initialized']
        init_keywords = ['å·²åˆå§‹åŒ–', 'initialized', 'initialization found']

        if any(kw in hypothesis for kw in uninit_keywords):
            if any(kw in observation.lower() for kw in init_keywords):
                return True

        return False

    def _check_unreachable_function(self, hypothesis: str, observation: str) -> bool:
        """æ£€æµ‹ï¼šå‡è®¾å‡½æ•°è§¦å‘ â†’ å‡½æ•°ä¸å¯è¾¾"""
        if 'trigger' in hypothesis or 'è§¦å‘' in hypothesis:
            unreachable_keywords = ['not found', 'unreachable', 'never called', 'æœªæ‰¾åˆ°', 'ä¸å¯è¾¾']
            if any(kw in observation.lower() for kw in unreachable_keywords):
                return True

        return False
```

---

## ä¿®æ”¹åˆ‡å…¥ç‚¹ 3ï¼šé…ç½®å±‚ Prompt æ¨¡æ¿ â­â­

**ä½ç½®**ï¼š`config/secb_hypothesis_driven.yaml` (æ–°æ–‡ä»¶)

**ç›®æ ‡**ï¼šå®šä¹‰å‡è®¾é©±åŠ¨çš„ Prompt æ¨¡æ¿å’Œé…ç½®

### å®Œæ•´é…ç½®æ–‡ä»¶

```yaml
# config/secb_hypothesis_driven.yaml
agent:
  # -------------------------------------------------------------------------
  # Prompt æ¨¡æ¿ï¼ˆæ”¯æŒ Jinja2ï¼‰
  # -------------------------------------------------------------------------
  templates:
    system_template: |
      You are a security vulnerability analysis agent using a **hypothesis-driven approach**.

      ## ğŸ¯ Your Mission
      Verify the current hypothesis by collecting evidence through systematic exploration.

      ## ğŸ“‹ Current Hypothesis (FOCUS HERE)
      **ID**: {{current_hypothesis.id}}
      **Description**: {{current_hypothesis.description}}
      **Priority**: {{current_hypothesis.priority}}
      **Expected Evidence**: {{current_hypothesis.expected_evidence}}

      ## ğŸ“ Suggested Verification Steps (Follow in Order)
      {% for step in current_hypothesis.suggested_steps %}
      {{loop.index}}. {{step}}
      {% endfor %}

      ## ğŸ” Ground Truth from Sanitizer Report (Your Anchor)
      - **Error Type**: {{sanitizer_info.error_type}}
      - **Crash Location**: {{sanitizer_info.crash_location}}
      - **Crash Function**: {{sanitizer_info.crash_function}}
      - **Call Stack** (top 5 frames):
      {% for frame in sanitizer_info.call_stack[:5] %}
        {{loop.index}}. {{frame.file}}:{{frame.line}} ({{frame.function}})
      {% endfor %}

      ## ğŸ’¡ What We Already Know
      {% if discoveries %}
      ### Key Findings
      {% for discovery in discoveries %}
      {{loop.index}}. {{discovery}}
      {% endfor %}
      {% else %}
      No discoveries yet. Start by following the suggested verification steps.
      {% endif %}

      ## ğŸ“Š Verification History (Current Hypothesis)
      - **Total Attempts**: {{verification_attempts|length}}
      - **Consecutive Failures**: {{consecutive_failures}}
      {% if verification_attempts %}
      - **Recent Actions**:
      {% for attempt in verification_attempts[-3:] %}
        - {{attempt.action}}: {{attempt.outcome}}
      {% endfor %}
      {% endif %}

      ## ğŸš¨ CRITICAL: Hypothesis Switching Protocol

      **HIGH THRESHOLD FOR SWITCHING** - Only request `hypothesis_switch` when:

      1. **Direct Contradiction**: You found code that directly contradicts the hypothesis
         - Example: Hypothesis says "missing validation" â†’ You found the validation code
         - Example: Hypothesis says "uninitialized variable" â†’ You found initialization

      2. **Exhausted All Paths**: You've completed all suggested_steps but didn't find expected evidence
         - All files checked
         - All functions analyzed
         - No evidence of the hypothesized root cause

      3. **Persistent PoC Failures**: DockerScript attempts fail 5+ times with no progress
         - Same error pattern
         - No new insights
         - Cannot trigger the vulnerability

      **DO NOT SWITCH** just because:
      - âŒ One action didn't find useful information
      - âŒ The current path seems difficult
      - âŒ You want to "try something different"

      ## ğŸ› ï¸ Available Actions

      - **Read**: View file content
        - Use for suggested_steps like "Read file.c:100-200"
        - Focus on crash location and call stack

      - **Find**: Search for functions/patterns
        - Use when suggested_steps mention "find X"
        - Explore related code

      - **Task**: Delegate complex analysis to Sub-Agent
        - Use for "analyze lifecycle", "trace dataflow"
        - Get structured analysis results

      - **DockerScript**: Write and execute PoC
        - Use when you have enough evidence
        - Test your hypothesis

      - **hypothesis_switch**: Switch to fallback hypothesis
        - **HIGH THRESHOLD** - Use only when hypothesis is clearly wrong
        - Provide detailed reason citing evidence

      ## âœ… Success Detection

      If your PoC triggers the vulnerability (crash/ASAN report in observation),
      you've confirmed the hypothesis! Immediately call: `submit_poc()`

    instance_template: |
      {{problem_statement}}

      **IMPORTANT**: Before starting analysis, you MUST:
      1. Call `sanitizer_analysis()` to extract Ground Truth
      2. Call `init_hypotheses()` to generate candidate hypotheses
      3. Then begin verifying the primary hypothesis

    next_step_template: |
      {{observation}}

      Based on the above observation and your current hypothesis, what's your next action?

  # -------------------------------------------------------------------------
  # æ¨¡å‹é…ç½®
  # -------------------------------------------------------------------------
  model:
    name: "deepseek/deepseek-chat"  # é»˜è®¤æ¨¡å‹ï¼Œå¯è¢« CLI è¦†ç›–
    temperature: 0.0
    top_p: 0.95
    per_instance_call_limit: 50     # å‡å°‘é™åˆ¶ï¼ˆä¸å†éœ€è¦ MCTS æ‰©å±•ï¼‰
    per_instance_cost_limit: 2.0
    delay: 1.0

# ============================================================================
# å·¥å…·é…ç½®
# ============================================================================
tools:
  execution_timeout: 300
  env_variables:
    WINDOW: 100
    OVERLAP: 2

  bundles:
    # åŸºç¡€å·¥å…·
    - path: tools/registry
    - path: tools/defaults
    - path: tools/search
    - path: tools/change          # Patch æ¨¡å¼éœ€è¦

    # SEC-bench ä¸“ç”¨
    - path: tools/submit_poc

    # â­ æ–°å¢ï¼šå‡è®¾é©±åŠ¨ä¸“ç”¨å·¥å…·
    - path: tools/sanitizer_analysis
    - path: tools/hypothesis_switch
    - path: tools/init_hypotheses

  enable_bash_tool: true
  parse_function:
    type: function_calling

# ============================================================================
# å†å²å¤„ç†å™¨ï¼ˆç®€åŒ–ï¼‰
# ============================================================================
history_processors:
  - type: last_n_observations
    n: 10  # ä¿ç•™æ›´å¤šå†å²

# ============================================================================
# å‡è®¾é©±åŠ¨é…ç½®ï¼ˆæ–°å¢ï¼‰
# ============================================================================
hypothesis:
  enabled: true
  phase0_service_url: "http://localhost:5000"

  # å‡è®¾åˆ‡æ¢é…ç½®
  auto_switch_on_deadend: true
  deadend_threshold: 5
  max_iterations_per_hypothesis: 30

  # çŸ›ç›¾æ£€æµ‹å…³é”®è¯
  contradiction_keywords:
    - "å·²åˆå§‹åŒ–"
    - "å­˜åœ¨æ£€æŸ¥"
    - "ä¸å¯èƒ½è§¦å‘"
    - "initialized"
    - "found check"
    - "unreachable"
```

---

## ä¿®æ”¹åˆ‡å…¥ç‚¹ 4ï¼šå·¥å…·å±‚æ‰©å±• â­

**ä½ç½®**ï¼š`tools/` ç›®å½•

**ç›®æ ‡**ï¼šæ–°å¢ 3 ä¸ªè‡ªå®šä¹‰å·¥å…·

### å·¥å…· 1ï¼šsanitizer_analysis

```
tools/sanitizer_analysis/
â”œâ”€â”€ config.yaml
â”œâ”€â”€ bin/
â”‚   â””â”€â”€ sanitizer_analysis
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ sanitizer_parser.py  # ä» VulnTree å¤åˆ¶
â””â”€â”€ README.md
```

**config.yaml**:
```yaml
name: sanitizer_analysis
signatures:
  - name: sanitizer_analysis
    description: |
      Parse the sanitizer report to extract Ground Truth information.

      **MUST be your first action** in every instance.

      Extracts:
      - Error type (NPD/UAF/Buffer overflow)
      - Crash location (file:line)
      - Crash function name
      - Complete call stack
      - For UAF: allocation/deallocation stacks

    arguments: []

    returns: |
      Ground Truth extracted and saved to /workspace/.hypothesis_state.json

      Summary:
      - Error Type: ...
      - Crash Location: ...
      - Call Stack: ... frames
```

**bin/sanitizer_analysis** (Python):
```python
#!/usr/bin/env python3
import sys
import os
import json

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../lib'))
from sanitizer_parser import SanitizerReportParser

def main():
    # 1. è¯»å– sanitizer report
    report_file = os.getenv('SANITIZER_REPORT_FILE', '/workspace/sanitizer_report.txt')

    with open(report_file, 'r') as f:
        report_text = f.read()

    # 2. è§£æ
    parser = SanitizerReportParser()
    parsed_info = parser.parse(report_text)

    if not parsed_info:
        print("ERROR: Failed to parse sanitizer report!")
        sys.exit(1)

    # 3. è¾“å‡º
    print("âœ… Ground Truth Extracted\n")
    print(f"Error Type: {parsed_info.error_type}")
    print(f"Crash Location: {parsed_info.crash_location}")
    print(f"Crash Function: {parsed_info.crash_function}")
    print(f"\nCall Stack ({len(parsed_info.call_stack)} frames)")

    # 4. ä¿å­˜åˆ°çŠ¶æ€æ–‡ä»¶
    state = {
        'sanitizer_info': {
            'error_type': parsed_info.error_type,
            'crash_location': parsed_info.crash_location,
            'crash_function': parsed_info.crash_function,
            'call_stack': [
                {'file': f.file, 'line': f.line, 'function': f.function}
                for f in parsed_info.call_stack
            ]
        },
        'hypotheses': {},
        'active_hypothesis_id': None,
        'discoveries': []
    }

    with open('/workspace/.hypothesis_state.json', 'w') as f:
        json.dump(state, f, indent=2)

    print("\nâœ… State initialized at /workspace/.hypothesis_state.json")

if __name__ == '__main__':
    main()
```

### å·¥å…· 2ï¼šinit_hypotheses

```
tools/init_hypotheses/
â”œâ”€â”€ config.yaml
â””â”€â”€ bin/
    â””â”€â”€ init_hypotheses
```

**config.yaml**:
```yaml
name: init_hypotheses
signatures:
  - name: init_hypotheses
    description: |
      Generate candidate hypotheses using Phase0 Sub-Agent.

      Must be called AFTER sanitizer_analysis.

      Generates 3-5 hypotheses with:
      - Description
      - Priority (1=highest)
      - Suggested verification steps
      - Expected evidence

    arguments: []

    returns: |
      Generated Hypotheses:

      H0_primary_uaf (Priority 1):
      Description: ...
      Suggested Steps: [...]

      H1_fallback_npd (Priority 2):
      Description: ...

      Active Hypothesis: H0_primary_uaf
```

**bin/init_hypotheses** (Python):
```python
#!/usr/bin/env python3
import requests
import json
import os

def main():
    # 1. è¯»å– sanitizer_info
    with open('/workspace/.hypothesis_state.json', 'r') as f:
        state = json.load(f)

    sanitizer_info = state['sanitizer_info']

    # 2. è°ƒç”¨ Phase0 æœåŠ¡
    phase0_url = os.getenv('PHASE0_SERVICE_URL', 'http://localhost:5000/generate_hypotheses')

    response = requests.post(phase0_url, json={
        'sanitizer_info': sanitizer_info,
        'vuln_type': os.getenv('VULN_TYPE', 'UAF')
    })

    if response.status_code != 200:
        print(f"ERROR: Phase0 service failed: {response.text}")
        exit(1)

    hypotheses = response.json()['hypotheses']

    # 3. æ›´æ–°çŠ¶æ€æ–‡ä»¶
    state['hypotheses'] = hypotheses
    state['active_hypothesis_id'] = hypotheses[0]['id']

    with open('/workspace/.hypothesis_state.json', 'w') as f:
        json.dump(state, f, indent=2)

    # 4. è¾“å‡º
    print(f"âœ… Generated {len(hypotheses)} Hypotheses\n")

    for hyp in hypotheses:
        print(f"\n{'='*60}")
        print(f"{hyp['id']} (Priority {hyp['priority']})")
        print(f"Description: {hyp['description']}")
        print(f"\nSuggested Steps:")
        for i, step in enumerate(hyp['suggested_steps'], 1):
            print(f"  {i}. {step}")

    print(f"\n{'='*60}")
    print(f"âœ… Activated: {hypotheses[0]['id']}")

if __name__ == '__main__':
    main()
```

### å·¥å…· 3ï¼šhypothesis_switch

```
tools/hypothesis_switch/
â”œâ”€â”€ config.yaml
â””â”€â”€ bin/
    â””â”€â”€ hypothesis_switch
```

**bin/hypothesis_switch** (Python):
```python
#!/usr/bin/env python3
import argparse
import json

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--current_hypothesis_id', required=True)
    parser.add_argument('--reason', required=True)
    parser.add_argument('--next_hypothesis_id', required=False)
    args = parser.parse_args()

    # 1. åŠ è½½çŠ¶æ€
    with open('/workspace/.hypothesis_state.json', 'r') as f:
        state = json.load(f)

    # 2. æ ‡è®°å½“å‰å‡è®¾ä¸º REFUTED
    for h_id, h in state['hypotheses'].items():
        if h_id == args.current_hypothesis_id:
            h['status'] = 'REFUTED'
            h['refuted_reason'] = args.reason
            break

    # 3. æ¿€æ´»ä¸‹ä¸€ä¸ªå‡è®¾
    if args.next_hypothesis_id:
        next_id = args.next_hypothesis_id
    else:
        # è‡ªåŠ¨é€‰æ‹©æœ€é«˜ä¼˜å…ˆçº§çš„ PENDING å‡è®¾
        pending = {h_id: h for h_id, h in state['hypotheses'].items()
                   if h['status'] == 'PENDING'}
        if not pending:
            print("ERROR: No fallback hypothesis available!")
            exit(1)
        next_id = sorted(pending.items(), key=lambda x: x[1]['priority'])[0][0]

    next_hyp = state['hypotheses'][next_id]
    next_hyp['status'] = 'ACTIVE'
    state['active_hypothesis_id'] = next_id

    # 4. ä¿å­˜çŠ¶æ€
    with open('/workspace/.hypothesis_state.json', 'w') as f:
        json.dump(state, f, indent=2)

    # 5. è¾“å‡º
    print(f"âœ… Hypothesis Switched\n")
    print(f"Refuted: {args.current_hypothesis_id}")
    print(f"Reason: {args.reason}\n")
    print(f"Activated: {next_id}")
    print(f"Description: {next_hyp['description']}")
    print(f"\nNew Suggested Steps:")
    for i, step in enumerate(next_hyp['suggested_steps'], 1):
        print(f"  {i}. {step}")

if __name__ == '__main__':
    main()
```

---

## ä¿®æ”¹åˆ‡å…¥ç‚¹ 5ï¼šæ‰§è¡Œå…¥å£é€‚é… â­

**ä½ç½®**ï¼š`sweagent/run/run_single.py` å’Œ `sweagent/run/run_batch.py`

**ç›®æ ‡**ï¼šæ³¨å…¥ HypothesisAwareAgent

### ä¿®æ”¹ run_single.py

```python
# sweagent/run/run_single.py
from sweagent.agent.hypothesis_agent import HypothesisAwareAgent
from sweagent.state.hypothesis_orchestrator import HypothesisOrchestrator

def run_single():
    config = RunSingleConfig.from_yaml(...)

    # æ£€æŸ¥æ˜¯å¦å¯ç”¨å‡è®¾é©±åŠ¨
    if hasattr(config.agent, 'hypothesis_config') and config.agent.hypothesis_config.enabled:
        # â­ ä½¿ç”¨ HypothesisAwareAgent
        hypothesis_orchestrator = HypothesisOrchestrator()
        agent = HypothesisAwareAgent(
            config=config.agent,
            hypothesis_orchestrator=hypothesis_orchestrator
        )
    else:
        # æ ‡å‡† Agent
        agent = get_agent_from_config(config.agent)

    # åˆ›å»ºç¯å¢ƒ
    env = SWEEnv(instance, config)

    # è¿è¡Œ Agent
    result = agent.run(env, instance)

    return result
```

---

## æ€»ç»“ï¼šä¿®æ”¹æ¸…å•

### å¿…é¡»ä¿®æ”¹çš„æ–‡ä»¶ï¼ˆæ–°å¢ï¼‰

| æ–‡ä»¶è·¯å¾„ | ç±»å‹ | ä½œç”¨ |
|---------|------|------|
| `sweagent/agent/hypothesis_agent.py` | æ–°å¢ | å‡è®¾é©±åŠ¨çš„ Agent ä¸»å¾ªç¯ |
| `sweagent/state/hypothesis_orchestrator.py` | æ–°å¢ | å‡è®¾ç®¡ç†å™¨ï¼ˆæ ¸å¿ƒï¼‰ |
| `sweagent/state/verification_tracker.py` | æ–°å¢ | éªŒè¯å†å²è¿½è¸ª |
| `sweagent/state/contradiction_detector.py` | æ–°å¢ | çŸ›ç›¾æ£€æµ‹ |
| `sweagent/state/deadend_detector.py` | æ–°å¢ | æ­»è·¯æ£€æµ‹ |
| `config/secb_hypothesis_driven.yaml` | æ–°å¢ | å‡è®¾é©±åŠ¨é…ç½® |
| `tools/sanitizer_analysis/` | æ–°å¢ | Sanitizer è§£æå·¥å…· |
| `tools/init_hypotheses/` | æ–°å¢ | å‡è®¾ç”Ÿæˆå·¥å…· |
| `tools/hypothesis_switch/` | æ–°å¢ | å‡è®¾åˆ‡æ¢å·¥å…· |

### å¿…é¡»ä¿®æ”¹çš„æ–‡ä»¶ï¼ˆç°æœ‰ï¼‰

| æ–‡ä»¶è·¯å¾„ | ä¿®æ”¹å†…å®¹ |
|---------|---------|
| `sweagent/agent/agents.py` | æ‰©å±• AgentConfigï¼Œæ·»åŠ  `hypothesis_config` å­—æ®µ |
| `sweagent/run/run_single.py` | æ£€æµ‹å‡è®¾é©±åŠ¨é…ç½®ï¼Œä½¿ç”¨ HypothesisAwareAgent |
| `run_secb.sh` | æ·»åŠ  `--config config/secb_hypothesis_driven.yaml` é€‰é¡¹ |

### å®æ–½ä¼˜å…ˆçº§

1. **P0ï¼ˆæ ¸å¿ƒï¼‰**ï¼š
   - âœ… `hypothesis_orchestrator.py`ï¼ˆçŠ¶æ€ç®¡ç†ï¼‰
   - âœ… `hypothesis_agent.py`ï¼ˆAgent ä¸»å¾ªç¯ï¼‰
   - âœ… `config/secb_hypothesis_driven.yaml`ï¼ˆPrompt æ¨¡æ¿ï¼‰

2. **P1ï¼ˆå·¥å…·ï¼‰**ï¼š
   - âœ… `sanitizer_analysis` å·¥å…·
   - âœ… `init_hypotheses` å·¥å…·
   - âœ… `hypothesis_switch` å·¥å…·

3. **P2ï¼ˆæ£€æµ‹ï¼‰**ï¼š
   - âœ… `contradiction_detector.py`
   - âœ… `deadend_detector.py`
   - âœ… `verification_tracker.py`

---

## ä¸‹ä¸€æ­¥è¡ŒåŠ¨

1. **ç«‹å³å¼€å§‹**ï¼šå®ç° `hypothesis_orchestrator.py`ï¼ˆæ ¸å¿ƒçŠ¶æ€ç®¡ç†ï¼‰
2. **å¿«é€ŸéªŒè¯**ï¼šä½¿ç”¨å•ä¸ª SEC-bench å®ä¾‹æµ‹è¯•çŠ¶æ€ä¿å­˜/åŠ è½½
3. **è¿­ä»£å®Œå–„**ï¼šé€æ­¥æ·»åŠ æ£€æµ‹å™¨å’Œå·¥å…·

æ‰€æœ‰ä¿®æ”¹éƒ½æ˜¯**å¢é‡å¼**çš„ï¼Œä¸ç ´åç°æœ‰ SWE-agent åŠŸèƒ½ã€‚ä½ å¯ä»¥é€šè¿‡ `--config` å‚æ•°é€‰æ‹©ä½¿ç”¨å‡è®¾é©±åŠ¨æ¨¡å¼æˆ–æ ‡å‡†æ¨¡å¼ã€‚
