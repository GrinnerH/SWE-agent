# SWE-agent 假设驱动修改切入点详解

基于 `完整工作流分析.md` 的架构分析，精确定位假设管理、分支切换的实现位置。

---

## 核心执行流回顾

```
┌─────────────────────────────────────────────────────────────┐
│ 1. run_secb.sh                                              │
│    ↓ 调用                                                   │
│ 2. sweagent run-batch                                       │
│    ↓ 加载配置                                               │
│ 3. config/secb_poc.yaml (AgentConfig)                      │
│    ↓ 批量处理                                               │
│ 4. run_single_instance(instance, config)                   │
│    ├─ 创建 SWEEnv(instance, config)                        │
│    ├─ 初始化 Agent(config.agent)                           │
│    └─ agent.run(env, instance)  ← 核心循环                 │
│       ↓                                                      │
│ 5. Agent 执行循环 (最多 75 次迭代)                          │
│    Loop:                                                     │
│      ├─ 渲染 prompt (system + history + observation)       │
│      ├─ 调用 LLM 生成 action (JSON)                        │
│      ├─ 解析 action                                         │
│      ├─ 在容器中执行 action                                 │
│      ├─ 获取 observation                                    │
│      └─ 检查终止条件 (submit 或限制)                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 修改切入点 1：AgentConfig 扩展 ⭐⭐⭐

**位置**：`sweagent/agent/agents.py` 和 `sweagent/run/run_single.py`

**目标**：在 Agent 初始化时注入假设管理器

### 当前代码结构

```python
# sweagent/run/run_single.py
class RunSingleConfig(BaseSettings):
    instances: InstanceSourceConfig
    agent: AgentConfig  # ← 这是 Agent 配置
    output_dir: Path
    # ...

def run_single():
    config = RunSingleConfig.from_yaml(...)

    # 创建环境
    env = SWEEnv(instance, config)

    # 创建 Agent
    agent = get_agent_from_config(config.agent)  # ← 关键函数

    # 运行 Agent
    result = agent.run(env, instance)
```

### 修改方案 A：扩展 AgentConfig

```python
# sweagent/agent/agents.py (新增)
from dataclasses import dataclass, field
from typing import Optional

@dataclass
class HypothesisConfig:
    """假设驱动配置"""
    enabled: bool = True
    phase0_service_url: str = "http://localhost:5000"
    auto_switch_on_deadend: bool = True
    deadend_threshold: int = 5
    max_iterations_per_hypothesis: int = 30

    # 矛盾检测关键词
    contradiction_keywords: list[str] = field(default_factory=lambda: [
        "已初始化", "存在检查", "不可能触发"
    ])

@dataclass
class AgentConfig(BaseSettings):
    # 原有字段
    templates: TemplateConfig
    model: ModelConfig
    tools: ToolsConfig
    history_processors: list[HistoryProcessorConfig]

    # ⭐ 新增字段
    hypothesis_config: Optional[HypothesisConfig] = None
```

### 修改方案 B：创建 HypothesisAwareAgent

```python
# sweagent/agent/hypothesis_agent.py (新文件)
from sweagent.agent.agents import Agent
from sweagent.state.hypothesis_orchestrator import HypothesisOrchestrator

class HypothesisAwareAgent(Agent):
    """假设驱动的 Agent"""

    def __init__(self, config: AgentConfig, hypothesis_orchestrator: HypothesisOrchestrator):
        super().__init__(config)
        self.hypothesis_orchestrator = hypothesis_orchestrator
        self.verification_tracker = VerificationTracker()
        self.contradiction_detector = ContradictionDetector(hypothesis_orchestrator)
        self.deadend_detector = DeadendDetector()

    def run(self, env: SWEEnv, instance: Any):
        """扩展的执行循环"""
        # 1. 初始化假设状态
        self._initialize_hypotheses(env, instance)

        # 2. 主循环
        for iteration in range(self.config.model.per_instance_call_limit):
            # 2.1 获取当前假设
            current_hypothesis = self.hypothesis_orchestrator.get_active_hypothesis()

            # 2.2 构造 prompt（注入假设上下文）
            prompt = self._build_prompt_with_hypothesis(
                env=env,
                hypothesis=current_hypothesis,
                iteration=iteration
            )

            # 2.3 生成 action
            action = self._generate_action(prompt)

            # 2.4 执行 action
            observation = self._execute_action(action, env)

            # 2.5 更新状态
            self._update_state(action, observation, current_hypothesis)

            # 2.6 检测验证结果
            result = self._detect_verification_result(observation, current_hypothesis)

            if result == VerificationResult.POC_SUCCESS:
                return self._handle_success(current_hypothesis)
            elif result == VerificationResult.CONTRADICTION:
                self._handle_contradiction(observation, current_hypothesis)
            elif result == VerificationResult.DEADEND:
                self._handle_deadend(current_hypothesis)

            # 2.7 检查终止条件
            if self._should_terminate(observation):
                break

        return self._finalize_result()

    def _initialize_hypotheses(self, env, instance):
        """Phase 0: 初始化假设"""
        # Step 1: 解析 Sanitizer 报告
        sanitizer_info = self._parse_sanitizer_report(instance.problem_statement)

        # Step 2: 调用 Phase0 服务生成假设
        hypotheses = self._generate_hypotheses_from_phase0(sanitizer_info)

        # Step 3: 初始化 orchestrator
        self.hypothesis_orchestrator.initialize(
            hypotheses=hypotheses,
            sanitizer_info=sanitizer_info
        )

        logger.info(f"✅ Initialized {len(hypotheses)} hypotheses")

    def _build_prompt_with_hypothesis(self, env, hypothesis, iteration):
        """构造注入假设的 prompt"""
        # 基础 prompt（从配置加载）
        base_prompt = self.config.templates.system_template

        # 注入假设上下文
        hypothesis_context = f"""
## Current Hypothesis (Iteration {iteration})

**ID**: {hypothesis.id}
**Description**: {hypothesis.description}
**Priority**: {hypothesis.priority}
**Expected Evidence**: {hypothesis.expected_evidence}

### Suggested Verification Steps
{self._format_suggested_steps(hypothesis.suggested_steps)}

### Verification History (This Hypothesis)
- **Attempts**: {len(self.verification_tracker.get_attempts(hypothesis.id))}
- **Consecutive Failures**: {self.verification_tracker.get_consecutive_failures(hypothesis.id)}
"""

        # 注入 Sanitizer Ground Truth
        sanitizer_context = f"""
## Ground Truth from Sanitizer Report

- **Error Type**: {self.hypothesis_orchestrator.sanitizer_info['error_type']}
- **Crash Location**: {self.hypothesis_orchestrator.sanitizer_info['crash_location']}
- **Crash Function**: {self.hypothesis_orchestrator.sanitizer_info['crash_function']}
- **Call Stack** (top 5):
{self._format_call_stack(self.hypothesis_orchestrator.sanitizer_info['call_stack'][:5])}
"""

        # 注入已知发现
        discoveries_context = self._format_discoveries()

        # 组合 prompt
        full_prompt = f"""
{base_prompt}

{hypothesis_context}

{sanitizer_context}

{discoveries_context}

## 🎯 CRITICAL INSTRUCTIONS

### Hypothesis Loyalty (HIGH THRESHOLD FOR SWITCHING)
Only request `hypothesis_switch` when:
1. You find direct contradictory evidence
2. You've exhausted all suggested_steps without finding expected evidence
3. PoC attempts consistently fail (5+ times)

### Next Action
Based on the current hypothesis and verification history, what's your next action?
"""

        return full_prompt

    def _detect_verification_result(self, observation, current_hypothesis):
        """检测验证结果"""
        # 1. 检测 PoC 成功
        if self._is_poc_success(observation):
            return VerificationResult.POC_SUCCESS

        # 2. 检测矛盾
        is_contradiction, reason = self.contradiction_detector.check(
            observation, current_hypothesis
        )
        if is_contradiction:
            logger.warning(f"⚠️ Contradiction detected: {reason}")
            return VerificationResult.CONTRADICTION

        # 3. 检测死路
        is_deadend, reason = self.deadend_detector.check(
            hypothesis_id=current_hypothesis.id,
            tracker=self.verification_tracker
        )
        if is_deadend:
            logger.warning(f"⚠️ Deadend detected: {reason}")
            return VerificationResult.DEADEND

        # 4. 正常继续
        return VerificationResult.CONTINUE

    def _handle_contradiction(self, observation, current_hypothesis):
        """处理矛盾：切换假设"""
        logger.info(f"🔄 Handling contradiction, switching hypothesis...")

        # 1. 标记当前假设为 REFUTED
        self.hypothesis_orchestrator.refute_hypothesis(
            hypothesis_id=current_hypothesis.id,
            reason=observation.contradiction_reason
        )

        # 2. 激活 fallback 假设
        next_hypothesis = self.hypothesis_orchestrator.activate_fallback()

        if not next_hypothesis:
            logger.error("❌ No fallback hypothesis available!")
            raise NoFallbackHypothesisError()

        # 3. 清空验证历史
        self.verification_tracker.clear_hypothesis_attempts(current_hypothesis.id)

        logger.info(f"✅ Switched to hypothesis: {next_hypothesis.id}")

    def _is_poc_success(self, observation):
        """检测 PoC 是否成功触发漏洞"""
        success_indicators = [
            'ERROR: AddressSanitizer',
            'SEGV on unknown address',
            'heap-use-after-free',
            'null-pointer-dereference',
            'Segmentation fault',
            'core dumped'
        ]

        message = observation.message.lower()
        return any(indicator.lower() in message for indicator in success_indicators)
```

---

## 修改切入点 2：状态管理组件 ⭐⭐⭐

**位置**：`sweagent/state/` (新目录)

**目标**：实现假设状态管理、验证追踪、矛盾检测

### 目录结构

```
sweagent/state/
├── __init__.py
├── hypothesis_orchestrator.py     # 假设管理器（核心）
├── verification_tracker.py        # 验证历史追踪
├── contradiction_detector.py      # 矛盾检测
├── deadend_detector.py           # 死路检测
└── schemas.py                    # 数据结构定义
```

### 核心代码：hypothesis_orchestrator.py

```python
# sweagent/state/hypothesis_orchestrator.py
import json
from pathlib import Path
from typing import Optional, List, Dict, Any
from dataclasses import dataclass, asdict
from enum import Enum
import logging

logger = logging.getLogger(__name__)

class HypothesisStatus(Enum):
    PENDING = "pending"
    ACTIVE = "active"
    CONFIRMED = "confirmed"
    REFUTED = "refuted"
    INCONCLUSIVE = "inconclusive"

@dataclass
class Hypothesis:
    id: str
    description: str
    priority: int
    suggested_steps: List[str]
    expected_evidence: str
    status: HypothesisStatus = HypothesisStatus.PENDING
    refuted_reason: Optional[str] = None
    fallback_to: Optional[str] = None  # fallback 假设的 ID

class HypothesisOrchestrator:
    """假设管理器 - 核心状态管理组件"""

    def __init__(self, state_file: Path = Path("/workspace/.hypothesis_state.json")):
        self.state_file = state_file
        self.hypotheses: Dict[str, Hypothesis] = {}
        self.active_hypothesis_id: Optional[str] = None
        self.sanitizer_info: Dict[str, Any] = {}
        self.discoveries: List[str] = []

    def initialize(self, hypotheses: List[Dict], sanitizer_info: Dict):
        """初始化假设和 Ground Truth"""
        # 1. 保存 Sanitizer 信息
        self.sanitizer_info = sanitizer_info

        # 2. 构建假设对象
        for hyp_data in hypotheses:
            hypothesis = Hypothesis(
                id=hyp_data['id'],
                description=hyp_data['description'],
                priority=hyp_data['priority'],
                suggested_steps=hyp_data['suggested_steps'],
                expected_evidence=hyp_data['expected_evidence'],
                status=HypothesisStatus.PENDING,
                fallback_to=hyp_data.get('fallback_to')
            )
            self.hypotheses[hypothesis.id] = hypothesis

        # 3. 激活最高优先级假设
        primary = sorted(hypotheses, key=lambda h: h['priority'])[0]
        self.activate_hypothesis(primary['id'])

        # 4. 保存状态
        self.save_state()

        logger.info(f"✅ Initialized {len(hypotheses)} hypotheses")
        logger.info(f"✅ Activated primary hypothesis: {primary['id']}")

    def activate_hypothesis(self, hypothesis_id: str):
        """激活指定假设"""
        if hypothesis_id not in self.hypotheses:
            raise ValueError(f"Hypothesis {hypothesis_id} not found")

        # 将当前 active 假设标记为 pending（如果存在）
        if self.active_hypothesis_id:
            current = self.hypotheses[self.active_hypothesis_id]
            if current.status == HypothesisStatus.ACTIVE:
                current.status = HypothesisStatus.PENDING

        # 激活新假设
        self.hypotheses[hypothesis_id].status = HypothesisStatus.ACTIVE
        self.active_hypothesis_id = hypothesis_id

        self.save_state()

    def get_active_hypothesis(self) -> Optional[Hypothesis]:
        """获取当前活跃假设"""
        if not self.active_hypothesis_id:
            return None
        return self.hypotheses.get(self.active_hypothesis_id)

    def refute_hypothesis(self, hypothesis_id: str, reason: str):
        """标记假设为 REFUTED"""
        hypothesis = self.hypotheses[hypothesis_id]
        hypothesis.status = HypothesisStatus.REFUTED
        hypothesis.refuted_reason = reason

        logger.info(f"❌ Refuted hypothesis {hypothesis_id}: {reason}")
        self.save_state()

    def confirm_hypothesis(self, hypothesis_id: str):
        """标记假设为 CONFIRMED"""
        hypothesis = self.hypotheses[hypothesis_id]
        hypothesis.status = HypothesisStatus.CONFIRMED

        logger.info(f"✅ Confirmed hypothesis {hypothesis_id}")
        self.save_state()

    def activate_fallback(self) -> Optional[Hypothesis]:
        """激活 fallback 假设"""
        current = self.get_active_hypothesis()

        # 1. 检查是否有显式 fallback
        if current.fallback_to:
            fallback = self.hypotheses.get(current.fallback_to)
            if fallback and fallback.status == HypothesisStatus.PENDING:
                self.activate_hypothesis(fallback.id)
                return fallback

        # 2. 自动选择最高优先级的 PENDING 假设
        pending = [h for h in self.hypotheses.values()
                   if h.status == HypothesisStatus.PENDING]

        if not pending:
            logger.error("❌ No fallback hypothesis available!")
            return None

        next_hypothesis = sorted(pending, key=lambda h: h.priority)[0]
        self.activate_hypothesis(next_hypothesis.id)

        return next_hypothesis

    def add_discovery(self, discovery: str):
        """记录新发现"""
        self.discoveries.append(discovery)
        self.save_state()

    def save_state(self):
        """保存状态到文件"""
        state = {
            'hypotheses': {
                h_id: {
                    'id': h.id,
                    'description': h.description,
                    'priority': h.priority,
                    'suggested_steps': h.suggested_steps,
                    'expected_evidence': h.expected_evidence,
                    'status': h.status.value,
                    'refuted_reason': h.refuted_reason,
                    'fallback_to': h.fallback_to
                }
                for h_id, h in self.hypotheses.items()
            },
            'active_hypothesis_id': self.active_hypothesis_id,
            'sanitizer_info': self.sanitizer_info,
            'discoveries': self.discoveries
        }

        with open(self.state_file, 'w') as f:
            json.dump(state, f, indent=2)

    def load_state(self):
        """从文件加载状态"""
        if not self.state_file.exists():
            logger.warning(f"State file {self.state_file} not found")
            return

        with open(self.state_file, 'r') as f:
            state = json.load(f)

        # 重建假设对象
        self.hypotheses = {
            h_id: Hypothesis(
                id=h_data['id'],
                description=h_data['description'],
                priority=h_data['priority'],
                suggested_steps=h_data['suggested_steps'],
                expected_evidence=h_data['expected_evidence'],
                status=HypothesisStatus(h_data['status']),
                refuted_reason=h_data.get('refuted_reason'),
                fallback_to=h_data.get('fallback_to')
            )
            for h_id, h_data in state['hypotheses'].items()
        }

        self.active_hypothesis_id = state['active_hypothesis_id']
        self.sanitizer_info = state['sanitizer_info']
        self.discoveries = state['discoveries']
```

### 验证追踪器：verification_tracker.py

```python
# sweagent/state/verification_tracker.py
from dataclasses import dataclass
from typing import List
import time

@dataclass
class VerificationAttempt:
    hypothesis_id: str
    action: str
    outcome: str  # 'success', 'failure', 'neutral'
    timestamp: float
    observation_summary: str

class VerificationTracker:
    """验证历史追踪"""

    def __init__(self):
        self.attempts: List[VerificationAttempt] = []

    def record_attempt(self, hypothesis_id: str, action: str,
                       outcome: str, observation: str):
        """记录验证尝试"""
        attempt = VerificationAttempt(
            hypothesis_id=hypothesis_id,
            action=action,
            outcome=outcome,
            timestamp=time.time(),
            observation_summary=observation[:200]  # 只保存摘要
        )
        self.attempts.append(attempt)

    def get_attempts(self, hypothesis_id: str) -> List[VerificationAttempt]:
        """获取指定假设的所有验证尝试"""
        return [a for a in self.attempts if a.hypothesis_id == hypothesis_id]

    def get_consecutive_failures(self, hypothesis_id: str) -> int:
        """计算连续失败次数"""
        recent_attempts = [a for a in self.attempts[-10:]
                          if a.hypothesis_id == hypothesis_id]

        consecutive = 0
        for attempt in reversed(recent_attempts):
            if attempt.outcome == 'failure':
                consecutive += 1
            else:
                break

        return consecutive

    def get_hypothesis_iterations(self, hypothesis_id: str) -> int:
        """获取假设的总迭代次数"""
        return len([a for a in self.attempts if a.hypothesis_id == hypothesis_id])

    def clear_hypothesis_attempts(self, hypothesis_id: str):
        """清空指定假设的验证历史（切换假设时调用）"""
        self.attempts = [a for a in self.attempts
                        if a.hypothesis_id != hypothesis_id]
```

### 矛盾检测器：contradiction_detector.py

```python
# sweagent/state/contradiction_detector.py
import re
from typing import Tuple

class ContradictionDetector:
    """矛盾检测 - 检测观察结果是否与假设矛盾"""

    def __init__(self, hypothesis_orchestrator):
        self.orchestrator = hypothesis_orchestrator

    def check(self, observation, current_hypothesis) -> Tuple[bool, str]:
        """
        检测矛盾
        返回: (is_contradiction, reason)
        """
        message = observation.message
        hyp_desc = current_hypothesis.description.lower()

        # 规则 1：假设"缺少 X" → 实际找到了 X
        if self._check_missing_vs_found(hyp_desc, message):
            return True, "Expected missing code was found"

        # 规则 2：假设"未初始化" → 实际找到初始化
        if self._check_uninitialized_vs_initialized(hyp_desc, message):
            return True, "Variable is actually initialized"

        # 规则 3：假设"函数 X 触发" → 函数不可达
        if self._check_unreachable_function(hyp_desc, message):
            return True, "Assumed trigger function is unreachable"

        return False, None

    def _check_missing_vs_found(self, hypothesis: str, observation: str) -> bool:
        """检测：假设缺少 X → 实际找到 X"""
        missing_patterns = [
            r'缺少.*?(\w+)',
            r'missing\s+(\w+)',
            r'without\s+(\w+)',
            r'lacks\s+(\w+)'
        ]

        found_patterns = [
            r'找到.*?(\w+)',
            r'found\s+(\w+)',
            r'exists\s+(\w+)',
            r'已存在.*?(\w+)'
        ]

        # 提取假设中声称缺少的内容
        for pattern in missing_patterns:
            match = re.search(pattern, hypothesis, re.IGNORECASE)
            if match:
                missing_item = match.group(1)

                # 检查观察中是否声称找到了它
                for found_pattern in found_patterns:
                    if re.search(found_pattern.replace(r'(\w+)', missing_item),
                                observation, re.IGNORECASE):
                        return True

        return False

    def _check_uninitialized_vs_initialized(self, hypothesis: str, observation: str) -> bool:
        """检测：假设未初始化 → 实际已初始化"""
        uninit_keywords = ['未初始化', 'uninitialized', 'not initialized']
        init_keywords = ['已初始化', 'initialized', 'initialization found']

        if any(kw in hypothesis for kw in uninit_keywords):
            if any(kw in observation.lower() for kw in init_keywords):
                return True

        return False

    def _check_unreachable_function(self, hypothesis: str, observation: str) -> bool:
        """检测：假设函数触发 → 函数不可达"""
        if 'trigger' in hypothesis or '触发' in hypothesis:
            unreachable_keywords = ['not found', 'unreachable', 'never called', '未找到', '不可达']
            if any(kw in observation.lower() for kw in unreachable_keywords):
                return True

        return False
```

---

## 修改切入点 3：配置层 Prompt 模板 ⭐⭐

**位置**：`config/secb_hypothesis_driven.yaml` (新文件)

**目标**：定义假设驱动的 Prompt 模板和配置

### 完整配置文件

```yaml
# config/secb_hypothesis_driven.yaml
agent:
  # -------------------------------------------------------------------------
  # Prompt 模板（支持 Jinja2）
  # -------------------------------------------------------------------------
  templates:
    system_template: |
      You are a security vulnerability analysis agent using a **hypothesis-driven approach**.

      ## 🎯 Your Mission
      Verify the current hypothesis by collecting evidence through systematic exploration.

      ## 📋 Current Hypothesis (FOCUS HERE)
      **ID**: {{current_hypothesis.id}}
      **Description**: {{current_hypothesis.description}}
      **Priority**: {{current_hypothesis.priority}}
      **Expected Evidence**: {{current_hypothesis.expected_evidence}}

      ## 📝 Suggested Verification Steps (Follow in Order)
      {% for step in current_hypothesis.suggested_steps %}
      {{loop.index}}. {{step}}
      {% endfor %}

      ## 🔍 Ground Truth from Sanitizer Report (Your Anchor)
      - **Error Type**: {{sanitizer_info.error_type}}
      - **Crash Location**: {{sanitizer_info.crash_location}}
      - **Crash Function**: {{sanitizer_info.crash_function}}
      - **Call Stack** (top 5 frames):
      {% for frame in sanitizer_info.call_stack[:5] %}
        {{loop.index}}. {{frame.file}}:{{frame.line}} ({{frame.function}})
      {% endfor %}

      ## 💡 What We Already Know
      {% if discoveries %}
      ### Key Findings
      {% for discovery in discoveries %}
      {{loop.index}}. {{discovery}}
      {% endfor %}
      {% else %}
      No discoveries yet. Start by following the suggested verification steps.
      {% endif %}

      ## 📊 Verification History (Current Hypothesis)
      - **Total Attempts**: {{verification_attempts|length}}
      - **Consecutive Failures**: {{consecutive_failures}}
      {% if verification_attempts %}
      - **Recent Actions**:
      {% for attempt in verification_attempts[-3:] %}
        - {{attempt.action}}: {{attempt.outcome}}
      {% endfor %}
      {% endif %}

      ## 🚨 CRITICAL: Hypothesis Switching Protocol

      **HIGH THRESHOLD FOR SWITCHING** - Only request `hypothesis_switch` when:

      1. **Direct Contradiction**: You found code that directly contradicts the hypothesis
         - Example: Hypothesis says "missing validation" → You found the validation code
         - Example: Hypothesis says "uninitialized variable" → You found initialization

      2. **Exhausted All Paths**: You've completed all suggested_steps but didn't find expected evidence
         - All files checked
         - All functions analyzed
         - No evidence of the hypothesized root cause

      3. **Persistent PoC Failures**: DockerScript attempts fail 5+ times with no progress
         - Same error pattern
         - No new insights
         - Cannot trigger the vulnerability

      **DO NOT SWITCH** just because:
      - ❌ One action didn't find useful information
      - ❌ The current path seems difficult
      - ❌ You want to "try something different"

      ## 🛠️ Available Actions

      - **Read**: View file content
        - Use for suggested_steps like "Read file.c:100-200"
        - Focus on crash location and call stack

      - **Find**: Search for functions/patterns
        - Use when suggested_steps mention "find X"
        - Explore related code

      - **Task**: Delegate complex analysis to Sub-Agent
        - Use for "analyze lifecycle", "trace dataflow"
        - Get structured analysis results

      - **DockerScript**: Write and execute PoC
        - Use when you have enough evidence
        - Test your hypothesis

      - **hypothesis_switch**: Switch to fallback hypothesis
        - **HIGH THRESHOLD** - Use only when hypothesis is clearly wrong
        - Provide detailed reason citing evidence

      ## ✅ Success Detection

      If your PoC triggers the vulnerability (crash/ASAN report in observation),
      you've confirmed the hypothesis! Immediately call: `submit_poc()`

    instance_template: |
      {{problem_statement}}

      **IMPORTANT**: Before starting analysis, you MUST:
      1. Call `sanitizer_analysis()` to extract Ground Truth
      2. Call `init_hypotheses()` to generate candidate hypotheses
      3. Then begin verifying the primary hypothesis

    next_step_template: |
      {{observation}}

      Based on the above observation and your current hypothesis, what's your next action?

  # -------------------------------------------------------------------------
  # 模型配置
  # -------------------------------------------------------------------------
  model:
    name: "deepseek/deepseek-chat"  # 默认模型，可被 CLI 覆盖
    temperature: 0.0
    top_p: 0.95
    per_instance_call_limit: 50     # 减少限制（不再需要 MCTS 扩展）
    per_instance_cost_limit: 2.0
    delay: 1.0

# ============================================================================
# 工具配置
# ============================================================================
tools:
  execution_timeout: 300
  env_variables:
    WINDOW: 100
    OVERLAP: 2

  bundles:
    # 基础工具
    - path: tools/registry
    - path: tools/defaults
    - path: tools/search
    - path: tools/change          # Patch 模式需要

    # SEC-bench 专用
    - path: tools/submit_poc

    # ⭐ 新增：假设驱动专用工具
    - path: tools/sanitizer_analysis
    - path: tools/hypothesis_switch
    - path: tools/init_hypotheses

  enable_bash_tool: true
  parse_function:
    type: function_calling

# ============================================================================
# 历史处理器（简化）
# ============================================================================
history_processors:
  - type: last_n_observations
    n: 10  # 保留更多历史

# ============================================================================
# 假设驱动配置（新增）
# ============================================================================
hypothesis:
  enabled: true
  phase0_service_url: "http://localhost:5000"

  # 假设切换配置
  auto_switch_on_deadend: true
  deadend_threshold: 5
  max_iterations_per_hypothesis: 30

  # 矛盾检测关键词
  contradiction_keywords:
    - "已初始化"
    - "存在检查"
    - "不可能触发"
    - "initialized"
    - "found check"
    - "unreachable"
```

---

## 修改切入点 4：工具层扩展 ⭐

**位置**：`tools/` 目录

**目标**：新增 3 个自定义工具

### 工具 1：sanitizer_analysis

```
tools/sanitizer_analysis/
├── config.yaml
├── bin/
│   └── sanitizer_analysis
├── lib/
│   └── sanitizer_parser.py  # 从 VulnTree 复制
└── README.md
```

**config.yaml**:
```yaml
name: sanitizer_analysis
signatures:
  - name: sanitizer_analysis
    description: |
      Parse the sanitizer report to extract Ground Truth information.

      **MUST be your first action** in every instance.

      Extracts:
      - Error type (NPD/UAF/Buffer overflow)
      - Crash location (file:line)
      - Crash function name
      - Complete call stack
      - For UAF: allocation/deallocation stacks

    arguments: []

    returns: |
      Ground Truth extracted and saved to /workspace/.hypothesis_state.json

      Summary:
      - Error Type: ...
      - Crash Location: ...
      - Call Stack: ... frames
```

**bin/sanitizer_analysis** (Python):
```python
#!/usr/bin/env python3
import sys
import os
import json

sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../lib'))
from sanitizer_parser import SanitizerReportParser

def main():
    # 1. 读取 sanitizer report
    report_file = os.getenv('SANITIZER_REPORT_FILE', '/workspace/sanitizer_report.txt')

    with open(report_file, 'r') as f:
        report_text = f.read()

    # 2. 解析
    parser = SanitizerReportParser()
    parsed_info = parser.parse(report_text)

    if not parsed_info:
        print("ERROR: Failed to parse sanitizer report!")
        sys.exit(1)

    # 3. 输出
    print("✅ Ground Truth Extracted\n")
    print(f"Error Type: {parsed_info.error_type}")
    print(f"Crash Location: {parsed_info.crash_location}")
    print(f"Crash Function: {parsed_info.crash_function}")
    print(f"\nCall Stack ({len(parsed_info.call_stack)} frames)")

    # 4. 保存到状态文件
    state = {
        'sanitizer_info': {
            'error_type': parsed_info.error_type,
            'crash_location': parsed_info.crash_location,
            'crash_function': parsed_info.crash_function,
            'call_stack': [
                {'file': f.file, 'line': f.line, 'function': f.function}
                for f in parsed_info.call_stack
            ]
        },
        'hypotheses': {},
        'active_hypothesis_id': None,
        'discoveries': []
    }

    with open('/workspace/.hypothesis_state.json', 'w') as f:
        json.dump(state, f, indent=2)

    print("\n✅ State initialized at /workspace/.hypothesis_state.json")

if __name__ == '__main__':
    main()
```

### 工具 2：init_hypotheses

```
tools/init_hypotheses/
├── config.yaml
└── bin/
    └── init_hypotheses
```

**config.yaml**:
```yaml
name: init_hypotheses
signatures:
  - name: init_hypotheses
    description: |
      Generate candidate hypotheses using Phase0 Sub-Agent.

      Must be called AFTER sanitizer_analysis.

      Generates 3-5 hypotheses with:
      - Description
      - Priority (1=highest)
      - Suggested verification steps
      - Expected evidence

    arguments: []

    returns: |
      Generated Hypotheses:

      H0_primary_uaf (Priority 1):
      Description: ...
      Suggested Steps: [...]

      H1_fallback_npd (Priority 2):
      Description: ...

      Active Hypothesis: H0_primary_uaf
```

**bin/init_hypotheses** (Python):
```python
#!/usr/bin/env python3
import requests
import json
import os

def main():
    # 1. 读取 sanitizer_info
    with open('/workspace/.hypothesis_state.json', 'r') as f:
        state = json.load(f)

    sanitizer_info = state['sanitizer_info']

    # 2. 调用 Phase0 服务
    phase0_url = os.getenv('PHASE0_SERVICE_URL', 'http://localhost:5000/generate_hypotheses')

    response = requests.post(phase0_url, json={
        'sanitizer_info': sanitizer_info,
        'vuln_type': os.getenv('VULN_TYPE', 'UAF')
    })

    if response.status_code != 200:
        print(f"ERROR: Phase0 service failed: {response.text}")
        exit(1)

    hypotheses = response.json()['hypotheses']

    # 3. 更新状态文件
    state['hypotheses'] = hypotheses
    state['active_hypothesis_id'] = hypotheses[0]['id']

    with open('/workspace/.hypothesis_state.json', 'w') as f:
        json.dump(state, f, indent=2)

    # 4. 输出
    print(f"✅ Generated {len(hypotheses)} Hypotheses\n")

    for hyp in hypotheses:
        print(f"\n{'='*60}")
        print(f"{hyp['id']} (Priority {hyp['priority']})")
        print(f"Description: {hyp['description']}")
        print(f"\nSuggested Steps:")
        for i, step in enumerate(hyp['suggested_steps'], 1):
            print(f"  {i}. {step}")

    print(f"\n{'='*60}")
    print(f"✅ Activated: {hypotheses[0]['id']}")

if __name__ == '__main__':
    main()
```

### 工具 3：hypothesis_switch

```
tools/hypothesis_switch/
├── config.yaml
└── bin/
    └── hypothesis_switch
```

**bin/hypothesis_switch** (Python):
```python
#!/usr/bin/env python3
import argparse
import json

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--current_hypothesis_id', required=True)
    parser.add_argument('--reason', required=True)
    parser.add_argument('--next_hypothesis_id', required=False)
    args = parser.parse_args()

    # 1. 加载状态
    with open('/workspace/.hypothesis_state.json', 'r') as f:
        state = json.load(f)

    # 2. 标记当前假设为 REFUTED
    for h_id, h in state['hypotheses'].items():
        if h_id == args.current_hypothesis_id:
            h['status'] = 'REFUTED'
            h['refuted_reason'] = args.reason
            break

    # 3. 激活下一个假设
    if args.next_hypothesis_id:
        next_id = args.next_hypothesis_id
    else:
        # 自动选择最高优先级的 PENDING 假设
        pending = {h_id: h for h_id, h in state['hypotheses'].items()
                   if h['status'] == 'PENDING'}
        if not pending:
            print("ERROR: No fallback hypothesis available!")
            exit(1)
        next_id = sorted(pending.items(), key=lambda x: x[1]['priority'])[0][0]

    next_hyp = state['hypotheses'][next_id]
    next_hyp['status'] = 'ACTIVE'
    state['active_hypothesis_id'] = next_id

    # 4. 保存状态
    with open('/workspace/.hypothesis_state.json', 'w') as f:
        json.dump(state, f, indent=2)

    # 5. 输出
    print(f"✅ Hypothesis Switched\n")
    print(f"Refuted: {args.current_hypothesis_id}")
    print(f"Reason: {args.reason}\n")
    print(f"Activated: {next_id}")
    print(f"Description: {next_hyp['description']}")
    print(f"\nNew Suggested Steps:")
    for i, step in enumerate(next_hyp['suggested_steps'], 1):
        print(f"  {i}. {step}")

if __name__ == '__main__':
    main()
```

---

## 修改切入点 5：执行入口适配 ⭐

**位置**：`sweagent/run/run_single.py` 和 `sweagent/run/run_batch.py`

**目标**：注入 HypothesisAwareAgent

### 修改 run_single.py

```python
# sweagent/run/run_single.py
from sweagent.agent.hypothesis_agent import HypothesisAwareAgent
from sweagent.state.hypothesis_orchestrator import HypothesisOrchestrator

def run_single():
    config = RunSingleConfig.from_yaml(...)

    # 检查是否启用假设驱动
    if hasattr(config.agent, 'hypothesis_config') and config.agent.hypothesis_config.enabled:
        # ⭐ 使用 HypothesisAwareAgent
        hypothesis_orchestrator = HypothesisOrchestrator()
        agent = HypothesisAwareAgent(
            config=config.agent,
            hypothesis_orchestrator=hypothesis_orchestrator
        )
    else:
        # 标准 Agent
        agent = get_agent_from_config(config.agent)

    # 创建环境
    env = SWEEnv(instance, config)

    # 运行 Agent
    result = agent.run(env, instance)

    return result
```

---

## 总结：修改清单

### 必须修改的文件（新增）

| 文件路径 | 类型 | 作用 |
|---------|------|------|
| `sweagent/agent/hypothesis_agent.py` | 新增 | 假设驱动的 Agent 主循环 |
| `sweagent/state/hypothesis_orchestrator.py` | 新增 | 假设管理器（核心） |
| `sweagent/state/verification_tracker.py` | 新增 | 验证历史追踪 |
| `sweagent/state/contradiction_detector.py` | 新增 | 矛盾检测 |
| `sweagent/state/deadend_detector.py` | 新增 | 死路检测 |
| `config/secb_hypothesis_driven.yaml` | 新增 | 假设驱动配置 |
| `tools/sanitizer_analysis/` | 新增 | Sanitizer 解析工具 |
| `tools/init_hypotheses/` | 新增 | 假设生成工具 |
| `tools/hypothesis_switch/` | 新增 | 假设切换工具 |

### 必须修改的文件（现有）

| 文件路径 | 修改内容 |
|---------|---------|
| `sweagent/agent/agents.py` | 扩展 AgentConfig，添加 `hypothesis_config` 字段 |
| `sweagent/run/run_single.py` | 检测假设驱动配置，使用 HypothesisAwareAgent |
| `run_secb.sh` | 添加 `--config config/secb_hypothesis_driven.yaml` 选项 |

### 实施优先级

1. **P0（核心）**：
   - ✅ `hypothesis_orchestrator.py`（状态管理）
   - ✅ `hypothesis_agent.py`（Agent 主循环）
   - ✅ `config/secb_hypothesis_driven.yaml`（Prompt 模板）

2. **P1（工具）**：
   - ✅ `sanitizer_analysis` 工具
   - ✅ `init_hypotheses` 工具
   - ✅ `hypothesis_switch` 工具

3. **P2（检测）**：
   - ✅ `contradiction_detector.py`
   - ✅ `deadend_detector.py`
   - ✅ `verification_tracker.py`

---

## 下一步行动

1. **立即开始**：实现 `hypothesis_orchestrator.py`（核心状态管理）
2. **快速验证**：使用单个 SEC-bench 实例测试状态保存/加载
3. **迭代完善**：逐步添加检测器和工具

所有修改都是**增量式**的，不破坏现有 SWE-agent 功能。你可以通过 `--config` 参数选择使用假设驱动模式或标准模式。
