

# **SWE-agent PoC 生成失败分析报告**

## **1\. 执行摘要**

本报告旨在对 SWE-agent 在为 Nginx JavaScript (njs) 引擎的 CVE-2022-32414 漏洞生成概念验证（Proof of Concept, PoC）过程中所遭遇的失败进行深入、系统的分析。代理在执行了 137 个步骤后，未能成功触发漏洞，并最终因超出上下文窗口限制而终止。通过对完整的执行轨迹进行详尽审查，我们揭示了导致此次失败的深层次技术、方法论及工具层面的原因。

* **关键发现**:  
  1. **对漏洞的理解停留在表面**: 代理成功定位了漏洞触发点（njs\_vmcode.c:802）并识别了关键要素（async/await、for-in 循环），但未能深入理解漏洞的根本机制。其核心在于，代理未能对 for-in 循环迭代器在异步操作（await）挂起和恢复过程中的内部状态生命周期及其潜在的损坏风险进行建模和推理。  
  2. **迭代策略的退化**: 代理的 PoC 生成策略在初次尝试失败后，迅速从基于逻辑的分析退化为一系列缺乏因果关联的“暴力猜测”。它先后尝试了增加代码复杂度、触发属性访问器（getter）错误、施加内存压力以及使用超大对象等多种假设，这些假设之间缺乏逻辑递进，未能有效利用前一次失败的反馈来修正其对漏洞的理解。  
  3. **调试与反馈循环的失效**: 代理将“未崩溃”这一反馈信号视为简单的二元失败，而非一个可用于推断程序内部状态的宝贵信息。它未能提出并验证“为什么在当前 PoC 下程序没有崩溃？”这一关键问题，从而错失了逐步逼近正确触发条件的机会。  
  4. **环境交互能力的缺失**: 代理最终因上下文窗口超限而终止，但这并非失败的根本原因，而是其策略缺陷的直接后果。在最后阶段，代理试图通过创建一个包含 100,000 个属性的对象来触发漏洞，其 PoC 中的 console.log 产生了巨量标准输出，直接淹没了上下文窗口。这暴露了代理在环境交互、特别是 I/O 管理方面的严重不足。  
* **失败的根本原因**: 代理的核心失败在于其未能对跨越异步边界的内部、堆分配状态（njs\_property\_next\_t 结构体）的生命周期进行有效推理，无法构想出一种能够在该状态被异步上下文恢复机制错误处理或破坏的场景，而这正是触发此漏洞的关键所在。

## **2\. 详细分析**

### **2.1 漏洞理解分析**

代理对漏洞的理解表现出一种典型的“知其然，而不知其所以然”的模式。它成功地完成了初步的信息提取和定位，但在将这些表面信息转化为对底层机制的深刻洞察方面遭遇了彻底的失败。

#### **代理对漏洞的理解是否正确？**

从表面上看，代理的理解是部分正确的。它准确地识别了构成漏洞的几个关键“配料”：

1. **崩溃位置**: 在任务初期，代理便展现了出色的定位能力。在 **STEP 4** 中，它直接打开了漏洞报告中指出的 njs\_vmcode.c 文件，并将视窗定位到第 790 行附近，使其能够立即审查到 NJS\_VMCODE\_PROPERTY\_NEXT 操作码的处理逻辑以及发生段错误的第 802 行代码：if (next-\>index \< next-\>array-\>length) 1。  
2. **关键结构**: 代理认识到理解崩溃点涉及的数据结构至关重要。从 **STEP 8** 到 **STEP 13**，它进行了一系列有针对性的搜索，试图找到 njs\_vmcode\_prop\_next\_t 和 njs\_property\_next\_t 的定义，最终在 njs\_vmcode.h 和 njs\_value.h 中找到了相关结构体 1。  
3. **触发条件**: 代理从漏洞描述中正确提取了 async/await 和 for-in 循环是触发漏洞的必要条件。其后续所有的 PoC 尝试都围绕这两个核心要素构建。

然而，这种理解是肤浅的。代理仅仅是将这些关键词组合在一起，而没有形成一个关于它们如何相互作用以导致崩溃的连贯的因果模型。

#### **遗漏了哪些关键信息？**

代理遗漏了整个漏洞故事的核心情节：**状态在异步边界上的生命周期管理**。

崩溃的直接原因是 next-\>array 为 NULL。一个专业的安全研究员或开发人员会立刻提出一系列探索性的问题：

* next 指针（一个指向 njs\_property\_next\_t 结构体的指针）是从哪里来的？轨迹显示，在 **STEP 800**，它来自于 value2-\>data.u.next。  
* value2 又是什么？它是在 for-in 循环开始时，由 NJS\_VMCODE\_PROPERTY\_FOREACH 操作码创建并存储在虚拟机栈上的迭代器状态。  
* 这个状态的生命周期是怎样的？njs\_property\_next\_t 结构体是在 njs\_vmcode\_property\_foreach 函数中通过内存池（njs\_mp\_alloc）在堆上分配的。  
* 当 await 发生时，虚拟机的执行被挂起，当前的函数帧（包括 value2）被保存。当 Promise 被 resolve 后，njs\_await\_fulfilled 函数负责恢复现场并继续执行 njs\_vmcode\_interpreter。  
* **那么，最关键的问题是：在 await 挂起期间，最初分配的 njs\_property\_next\_t 结构体发生了什么？** 它是否可能被垃圾回收？或者，恢复上下文的机制是否存在缺陷，导致 value2 中存储的指针失效或被错误地覆盖？

这整个关于状态保存、挂起、恢复和潜在损坏的推理链条，在代理的 137 个步骤中完全缺席。代理在 **STEP 65** 中打开了 njs\_async.c，并观察到 njs\_await\_fulfilled 调用了 njs\_vmcode\_interpreter，它的思考是：“我可以看到在第 96 行，njs\_await\_fulfilled 使用保存的上下文调用了 njs\_vmcode\_interpreter。这意味着当一个异步函数恢复时，它会从它离开的地方继续执行” 1。这个结论是正确的，但也是平凡的。它描述了 await 的外部行为，却完全没有探索其内部实现。

代理从未搜索过与上下文管理相关的关键函数，如 njs\_function\_frame\_save，也未曾对内存池（vm-\>mem\_pool）的行为产生任何好奇。它看到了状态（next 结构体），但从未思考过这个状态的“时间维度”——它如何在时间中（尤其是在异步等待的时间段内）存在和变化。这种对动态状态管理的认知缺失，是其技术分析失败的根本原因。

### **2.2 探索阶段分析**

代理的探索阶段遵循了标准的、由指令驱动的流程，在广度上表现尚可，但在深度上严重不足。它找到了所有被明确提及的文件和结构，但未能主动探索那些未被明示但对理解漏洞至关重要的代码路径。

#### **探索策略评估**

代理的探索策略可以概括为“由点及面，但浅尝辄止”。

* **由点及面**: 它以崩溃日志中的文件名和行号为起点（njs\_vmcode.c:802），然后扩展到相关的函数（njs\_await\_fulfilled）和数据结构（njs\_property\_next\_t）。这是一个合理的初步策略。  
* **浅尝辄止**: 一旦找到了某个定义或引用点，探索就停止了。例如，在 **STEP 38** 之后，代理找到了 njs\_vmcode\_property\_foreach 函数是创建迭代器的地方 1。这是一个重大线索，因为它内部调用了 njs\_value\_enumerate，并且负责分配 next 结构体。然而，代理只是看了一眼，并没有深入分析 njs\_value\_enumerate 在何种情况下可能失败并返回 NULL，从而导致 next-\>array 成为 NULL。它看到了分配点，却没有思考分配失败或内存被释放的可能性。

#### **关键发现和遗漏**

* **关键发现**:  
  * **STEP 4**: 成功定位 njs\_vmcode.c:802 的崩溃点 1。  
  * **STEP 13**: 成功定位 njs\_property\_next\_t 的结构体定义 1。  
  * **STEP 38**: 成功定位 njs\_vmcode\_property\_foreach，即 for-in 迭代器的初始化函数 1。  
  * **STEP 65**: 成功定位 njs\_await\_fulfilled，即 await 恢复执行的入口点 1。  
* **关键遗漏**:  
  * **上下文保存机制**: 代理完全忽略了与 await 挂起操作相对应的状态保存机制。在 njs\_vmcode.c 中存在 NJS\_VMCODE\_AWAIT 操作码，它会调用 njs\_vmcode\_await，而后者内部会为异步操作保存当前的虚拟机状态。代理从未对这一半的操作进行过任何探索。  
  * **内存管理**: next 结构体是通过 njs\_mp\_alloc 从内存池中分配的。对于一个涉及异步操作和可能状态损坏的漏洞，内存管理是分析的重中之重。代理从未搜索过 njs\_mp\_alloc 或 njs\_mp\_free，也未曾思考过在 await 期间，这个内存池中的对象是否可能被意外释放。  
  * **错误处理路径**: 在 njs\_vmcode\_property\_foreach 中，如果 njs\_value\_enumerate 返回 NULL，函数会返回 NJS\_ERROR。代理看到了这个检查（**STEP 114** 1），但没有顺着这条线索去思考：一个失败的枚举操作是否可能导致后续恢复时出现状态不一致？

总而言之，代理的探索就像是仅仅阅读了函数的 API 文档，而没有深入其实现细节。对于这类涉及复杂状态交互的底层漏洞，这种程度的分析是远远不够的。

### **2.3 PoC 开发分析**

代理的 PoC 开发过程是其方法论缺陷最集中的体现。它展示了一个从合理的初始尝试迅速衰退为一系列无目的、非结构化实验的完整过程。这种策略上的失败，远比其对漏洞理解的技术性失败更为致命。

#### **初始 PoC 设计评估**

代理在 **STEP 68** 创建的第一个 PoC 是完全合乎逻辑的起点 1。

JavaScript

async function test() {  
    let obj \= {a: 1, b: 2, c: 3};  
    for (let key in obj) {  
        await Promise.resolve();  
        let value \= obj\[key\];  
        await Promise.resolve();  
    }  
}  
test().then(...)

这个 PoC 精确地复刻了漏洞描述中的核心要素：一个 async 函数和一个 for-in 循环，并在循环体内执行了 await。这是一个完美的“最小可复现”尝试，旨在验证最简单的组合是否足以触发漏洞。当它在 **STEP 69** 运行后未导致崩溃时，这本应是一个关键的学习机会 1。

#### **迭代策略分析**

真正的失败始于第一次尝试之后。代理的迭代策略并非基于对失败原因的深入分析和假设修正，而是一种发散性的、近乎随机的探索。下面的表格系统地剖析了其主要的迭代思路及其根本性缺陷：

| PoC 迭代 (步骤范围) | 代理的假设 | PoC 代码片段示例 (来自轨迹) | 结果与专家评估 |
| :---- | :---- | :---- | :---- |
| **68-71** | async 和 for-in 的简单组合足以触发状态损坏。 | async function test() { let obj \= {a:1}; for (let k in obj) { await Promise.resolve(); } } test(); | **未崩溃**: 假设过于简单。标准的 await 会正确地保存和恢复迭代器状态。代理未能追问 *为什么* 状态能被正确恢复，以及在何种情况下恢复会失败。 |
| **75-76** | 增加复杂性（如嵌套循环和更多 await）可能会暴露竞态条件或更深层次的错误。 | (在循环中添加了嵌套循环和多次 await) | **未崩溃**: 这是在没有新理论指导下的盲目增加复杂度。代理希望通过“把水搅浑”来偶然触发漏洞，而不是精确地构造触发条件。 |
| **81-82, 93-94** | 在枚举过程中，由属性的 getter 抛出异常可能会中断并损坏迭代器状态。 | let obj \= { get a() { throw new Error(...) } }; | **未崩溃/抛出异常**: 代理正确地从失败中学习到：for-in 枚举的是键，不会触发值的 getter。这是一个有效的局部学习，但它没有被整合回关于迭代器状态的整体模型中。 |
| **87-89, 122-126, 131-132** | 巨大的内存压力可能导致为迭代器分配内存（njs\_mp\_alloc）失败，从而使 next-\>array 为 NULL。 | // 创建 1000 个对象，每个对象 100 个属性 | **未崩溃**: 这是一个合理的、但完全不同的漏洞模型（内存耗尽）。代理的尝试是无的放矢的，它无法在 njs\_vmcode\_property\_foreach 执行的精确时刻制造出足够的、局部的内存压力来使其内部的特定分配失败。 |
| **135-136** | 一个拥有海量属性的对象可能会在枚举逻辑中触发某种未处理的边界情况。 | // 创建一个拥有 100,000 个属性的对象 | **上下文窗口超限**: 这是典型的“绝望的暴力破解”尝试，完全脱离了漏洞的异步特性。代理未能预见到 console.log 会产生巨量输出，这直接导致了任务的最终失败，并暴露了其环境意识的缺失。 |

这个过程清晰地表明，代理缺乏一个核心的、可演进的漏洞因果模型。它不是在“调试”，而是在“掷骰子”，期望其中一次尝试能偶然命中目标。

#### **为何未能触发漏洞？**

代理之所以失败，是因为它所有的尝试都未能破坏 for-in 循环在 await 期间所依赖的、保存在堆上的 njs\_property\_next\_t 结构体。正确的 PoC 需要构造一个场景，让这个结构体在 await 挂起期间被 njs 引擎的内存管理机制错误地回收。

一个可能的触发方式是：在一个 async 函数的 for-in 循环中，await 一个 Promise，而这个 Promise 的 resolve 函数会触发垃圾回收（GC）。如果 for-in 循环的迭代器状态（njs\_property\_next\_t）没有被 GC 正确地标记为“存活”，它就可能被回收。当 await 结束，函数恢复执行并试图访问这个已被回收的结构体时，就会发生段错误。

代理的所有 PoC，无论是增加对象数量还是属性数量，都没有直接影响到 GC 的行为与异步状态恢复之间的交互。它一直在问题的外围打转，从未触及核心机制。

### **2.4 验证和调试分析**

代理在验证和调试环节的表现暴露了其认知模型的另一个关键缺陷：它将复杂的程序行为简化为了一个二元输出（崩溃/不崩溃），从而丧失了从丰富的中间状态中学习的能力。

#### **验证方法是否充分？**

验证方法本身是正确的。使用 secb repro 命令是任务要求，也是验证 PoC 是否有效的标准流程 1。问题不在于验证的工具，而在于代理如何解读验证的结果。

#### **是否有效利用了反馈？**

完全没有。对于代理来说，secb repro 命令的输出只有两种情况：

1. **包含 Sanitizer 错误**: 成功，任务完成。  
2. **不包含 Sanitizer 错误**: 失败，丢弃当前假设，尝试一个全新的、不相关的假设。

这种反馈利用方式是极其低效的。一个经验丰富的开发者在看到 PoC 没有崩溃时，会启动一个调试过程。他们可能会使用调试器、打印日志，或者仅仅是进行思想实验，来回答这个问题：“在我的 PoC 执行路径下，next-\>array 的值是什么？为什么它不是 NULL？程序状态与我预期的有何不同？”

例如，当代理的“getter 抛出异常”的 PoC 失败时（**STEP 94** 1），它只是简单地记录“这不起作用”，然后转向内存压力。它没有问：“为什么 getter 没有被调用？哦，原来 for-in 只迭代键。这意味着我需要找到一种在迭代键的过程中就能破坏状态的方法，而不是在访问值的时候。” 这种基于失败的推理和模型修正从未发生。

#### **错过了哪些调试机会？**

代理错过了无数次通过观察“非崩溃”行为来理解程序内部状态的机会。

* **STEP 72**: 在修改 PoC 以删除对象属性后，程序仍然正常运行 1。这是一个强烈的信号，表明 for-in 的迭代器在循环开始时可能已经“快照”了对象的键列表，后续对对象的修改不会影响当前的循环。代理错过了这个理解 njs 引擎 for-in 实现细节的机会。  
* **STEP 126**: 在使用大量对象制造内存压力的尝试中，程序输出了大量内容但没有崩溃 1。代理本可以推断出，简单的内存占用增加并不会轻易导致 njs\_mp\_alloc 在关键路径上失败。这可能意味着需要更精巧的内存操作，比如在特定时间点进行大量分配和释放，以增加内存碎片或耗尽特定大小的内存池。

代理缺乏一种“探索性调试”的能力。它被任务目标（“触发崩溃”）所束缚，无法将“未触发崩溃”视为一个同样有价值的、包含信息的数据点。

### **2.5 上下文窗口问题**

上下文窗口超限是压垮骆驼的最后一根稻草，但其根源在于代理策略的彻底失败和工具链的脆弱性。

#### **如何避免输出过多？**

这个问题的解决方案对于任何有基本命令行经验的人来说都是显而易见的：**重定向标准输出**。

代理的目标是检测 AddressSanitizer 的输出，该输出被写入标准错误流（stderr）。而它的 PoC 中的 console.log 语句则写入标准输出流（stdout）。在 **STEP 136**，代理执行了 secb repro，导致 100,000 行属性名被打印到 stdout，这些输出被环境捕获并送回给 LLM，瞬间撑爆了上下文窗口 1。

一个更智能的代理或一个更鲁棒的执行环境应该能够区分这两种输出。代理本应执行 secb repro \> /dev/null。这个简单的修改会将所有 stdout 丢弃，只保留 stderr，从而完美地隔离出它唯一关心的崩溃信息。

代理未能采取这一简单步骤，揭示了两个问题：

1. **缺乏基本的“Shell 编程”常识**: 它不懂得如何使用重定向来管理 I/O 流。  
2. **缺乏对自身行为副作用的预见性**: 它在 PoC 中加入了 console.log 用于调试，但在大规模测试时，没有意识到这个调试语句会成为性能瓶颈和环境杀手。

#### **上下文管理策略建议**

除了代理侧的改进，SWE-agent 的执行环境（swea-env）也应更加智能。它可以实现一个输出截断和摘要机制。例如，当一个命令的 stdout 超过预设阈值（比如 100 KB）时，环境不应返回全部内容，而应返回一个摘要，例如：\[stdout truncated: 600,060 characters were elided. First 10 lines:... Last 10 lines:...\]. 与此同时，它应该完整地返回 stderr 的内容。这种机制可以从根本上防止代理因无心之失而“自杀”。

## **3\. 根本原因总结**

此次 PoC 生成任务的失败并非单一因素所致，而是一个多层面、系统性问题的集中体现。我们可以从技术、方法论和工具三个层面进行归纳。

### **技术层面（漏洞理解、代码分析）**

* **核心缺陷**: 未能理解和分析异步上下文切换过程中的状态管理。代理将 async/await 视为一个行为黑盒，而没有深入到其在 njs 虚拟机中的实现，特别是与函数帧保存、恢复以及内存管理相关的部分。这是最根本的技术短板。  
* **分析深度不足**: 代理的代码分析停留在函数签名和局部逻辑层面。它找到了相关的函数和数据结构，但从未将它们串联起来，形成一个完整的、跨越多个函数和模块的数据流与控制流图景。

### **方法论层面（探索策略、迭代方法）**

* **缺乏因果推理**: 代理的迭代过程缺乏严谨的科学方法。它没有形成一个基于证据的、可证伪的假设，并在每次实验失败后对该假设进行修正。相反，它在多个互不相关的“可能性”之间随机跳跃。  
* **反馈利用失败**: 代理将复杂的程序行为简化为“成功/失败”的二元信号，浪费了大量可以从“非崩溃”执行路径中获取的关于程序内部状态的宝贵信息。这反映了其调试和学习能力的严重缺失。

### **工具层面（工具能力、环境限制）**

* **I/O 管理脆弱**: 代理及其执行环境无法有效处理大量输出，导致任务在最后阶段因一个本可轻易避免的技术问题而终止。这表明工具链在鲁棒性方面存在设计缺陷。  
* **观测能力受限**: 代理缺乏有效的工具来“观测”程序在运行时的内部状态。除了 gdb（任务指南中提到只能用于非交互式脚本），它没有轻量级的追踪或日志分析工具来帮助它理解内存分配、函数调用顺序等动态行为。这使得它只能进行“黑盒”测试，大大增加了问题的难度。

## **4\. 改进建议**

基于以上分析，我们提出以下针对 SWE-agent 方法论、工具和工作流的具体改进建议，旨在提升其在处理类似复杂漏洞时的表现。

### **针对 SWE-agent 方法的建议**

#### **Prompt 改进示例**

为了引导代理进行更深层次的思考，应在系统提示中加入针对特定漏洞类型的“专家知识”或“分析框架”。

**建议的 Prompt 补充内容**:

---

**异步/并发漏洞分析指令**

当问题描述包含 'async', 'await', 'thread', 'race condition', 'context switch' 等关键词时，你的分析必须超越表面代码。请遵循以下步骤：

1. **识别关键状态**: 明确识别出与该操作相关的所有核心数据结构和变量（即“状态”）。  
2. **建模状态生命周期**: 深入研究并建模该状态的完整生命周期。它在何处被分配？何时被修改？何时被释放？它的所有权和作用域是怎样的？  
3. **分析异步边界**: 将你的分析焦点放在上下文切换的边界上（例如 await 调用点）。构建一个关于状态在边界两侧如何被保存、保持和恢复的具体假设。主动搜索负责这些状态管理的内部函数（例如 \_save\_context, \_restore\_frame 等）。  
4. **假设损坏机制**: 你的 PoC 策略必须基于一个关于状态管理如何失败的具体假设（例如：状态在挂起期间被垃圾回收、恢复时指针计算错误、use-after-free 等）。在你的思考过程中明确阐述这个假设。

---

**I/O 管理最佳实践**

当你的目标是检测标准错误（stderr）中的特定输出（如崩溃日志、Sanitizer 错误）时，如果你的命令或 PoC 可能会产生大量标准输出（stdout），请务必使用重定向将 stdout 发送到 /dev/null，以避免上下文窗口被无关信息填满。

**示例**: my\_command\_with\_lots\_of\_output \> /dev/null

#### **新工具需求**

为了弥补代理在动态分析和环境交互方面的短板，需要开发新的、更强大的工具。

1. **智能执行与输出摘要工具 (run\_and\_summarize)**  
   * **功能**: 封装命令执行逻辑。它应能同时捕获 stdout 和 stderr。  
   * **智能摘要**: 如果 stdout 的大小超过预设阈值（例如 10 KB），该工具不返回完整内容，而是返回一个结构化的摘要，如：{"stdout": {"truncated": true, "size": "600 KB", "head": "...", "tail": "..."}, "stderr": "..."}。stderr 始终完整返回。  
   * **收益**: 从根本上解决上下文窗口污染问题，使代理能够安全地运行可能产生大量输出的测试，而不会导致任务失败。  
2. **非交互式状态追踪工具 (trace\_allocations, trace\_calls)**  
   * **功能**: 提供一种轻量级的方式来窥探程序内部。  
     * trace\_allocations \[function\_name\]\[command\_to\_run\]: 在后台使用 gdb 脚本或类似机制，追踪在执行 command\_to\_run 期间，function\_name 内部所有对 malloc/free（或特定内存池函数如 njs\_mp\_alloc）的调用，并报告分配/释放的地址和大小。  
     * trace\_calls \[function\_name\]\[command\_to\_run\]: 使用 ltrace 或 gdb 脚本，记录 function\_name 的调用树或被调用序列。  
   * **收益**: 赋予代理“看见”内存动态行为的能力。在本次任务中，代理若能使用 trace\_allocations njs\_vmcode\_property\_foreach./run\_poc.sh，它或许就能观察到 njs\_property\_next\_t 结构体的分配和（可能的）意外释放，从而直接获得破解漏洞的关键线索。

#### **工作流的完善**

应在 SWE-agent 的核心控制循环中引入一个强制性的反思步骤，以避免其陷入无效的迭代。

1. **引入“失败分析（Failure Analysis）”状态**  
   * **工作流变更**: 当前的工作流是：PoC 开发 \-\> 验证 \-\> (失败) \-\> PoC 改进。应修改为：PoC 开发 \-\> 验证 \-\> (失败) \-\> **失败分析** \-\> PoC 改进。  
   * **失败分析 状态的提示**: 当 secb repro 未触发崩溃时，系统应向代理发出如下指令：“你的 PoC 未能触发漏洞，这表明你当前的假设不成立或不完整。**在尝试新的 PoC 之前，请暂停。** 首先，请基于你对程序内部状态的理解，详细解释为什么上一次的尝试失败了。然后，构建一个新的、更精确的、能够解释此次失败的假设。最后，基于这个经过修正的假设，构思你的下一个 PoC 方案。”  
   * **收益**: 此机制强制代理进行元认知（meta-cognition），将每次失败从一个简单的“重试”信号转变为一个学习和模型修正的机会。它鼓励代理从“广度优先的随机搜索”转向“深度优先的因果探索”，从而更有可能解决需要多步复杂推理的漏洞。

#### **引用的著作**

1. njs.cve-2022-32414.trace.log