上下文管理机制概览

  1. 历史处理器链 (History Processors Chain)

  项目的核心上下文管理通过可组合的历史处理器实现，位于 sweagent/agent/history_processors.py:535。这些处理器以责任链模式串联处理：

  for processor in self.history_processors:
      messages = processor(messages)

  2. 主要历史处理器类型

  LastNObservations (history_processors.py:77-141)

  - 功能：只保留最后 N 个观察结果
  - 轮询机制：通过 polling 参数优化缓存，避免每次都修改历史
  - 标签系统：
    - remove_output：强制删除的观察
    - keep_output：强制保留的观察
  - 策略：将旧观察替换为简短摘要，如 "Old environment output: (X lines omitted)"

  ClosedWindowHistoryProcessor (history_processors.py:179-223)

  - 功能：管理窗口化文件编辑的上下文
  - 机制：追踪每个文件的最新窗口，折叠过时窗口
  - 优化：将过时窗口替换为 "Outdated window with X lines omitted..."

  CacheControlHistoryProcessor (history_processors.py:225-267)

  - 功能：为 Anthropic Claude 添加提示缓存控制
  - 参数：
    - last_n_messages：对最后 N 条消息启用缓存（默认 2）
    - last_n_messages_offset：缓存偏移量
    - tagged_roles：只对特定角色（user/tool）缓存

  RemoveRegex (history_processors.py:269-297)

  - 功能：使用正则表达式移除历史中的特定内容
  - 用例：移除 diff 信息等临时内容，如 <diff>.*</diff>

  TagToolCallObservations (history_processors.py:143-177)

  - 功能：为特定工具调用的观察添加标签
  - 用途：配合其他处理器实现选择性保留

  3. 窗口化文件编辑 (tools/defaults/lib/windowed_file.py)

  这是一个独特的上下文管理机制：

  class WindowedFile:
      window: int        # 显示窗口大小（默认 100 行）
      overlap: int       # 滚动时的重叠行数
      first_line: int    # 窗口起始行

  关键特性：
  - 有限视窗：只显示文件的一部分（如 100 行）
  - 上下文提示：显示 (X more lines above/below)
  - 智能导航：goto() 和 scroll() 方法管理窗口位置
  - 状态追踪：记录当前文件、窗口位置等状态

  4. 配置驱动的处理器组合

  在配置文件中可以灵活组合多个处理器，例如 config/sweagent_heavy_sbl_250212.yaml:127-133：

  history_processors:
    - type: remove_regex
      keep_last: 2
      remove:
        - "<diff>.*</diff>"
    - type: cache_control
      last_n_messages: 2
      last_n_messages_offset: 2

  5. Token 和上下文窗口管理 (sweagent/agent/models.py)

  - 检测机制：通过 max_input_tokens 配置检测上下文窗口超限
  - 异常处理：抛出 ContextWindowExceededError
  - 提示缓存：利用 Anthropic 的提示缓存减少 token 消耗

  设计优势

  1. 模块化：每个处理器专注单一职责，可灵活组合
  2. 可配置：通过 YAML 配置不同策略，无需修改代码
  3. 智能压缩：渐进式压缩旧历史，保留关键信息
  4. 缓存优化：配合 LLM 提供商的缓存机制减少成本
  5. 窗口化编辑：限制文件上下文，避免超大文件淹没提示

  这套机制确保了在长对话中能够有效管理上下文，在保持关键信息的同时控制 token 使用量。