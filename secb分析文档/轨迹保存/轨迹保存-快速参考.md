# 轨迹保存机制 - 快速参考

## 🎯 核心回答

**是的！SWE-agent 有完整的轨迹保存机制。**

- ✅ **自动保存**：每步执行后自动保存
- ✅ **完整记录**：包含动作、观察、思考、对话历史
- ✅ **JSON 格式**：`.traj` 文件，易于解析
- ✅ **多日志**：`.trace.log`, `.debug.log`, `.info.log`
- ✅ **可重放**：`sweagent run-replay`
- ✅ **可检查**：`sweagent inspect`

## 📁 文件结构

```
trajectories/
└── <model>__<dataset>__<timestamp>/
    ├── instance_1/
    │   ├── instance_1.traj          ⭐ 主轨迹文件
    │   ├── instance_1.trace.log     📝 详细日志
    │   ├── instance_1.debug.log     🐛 调试日志
    │   └── instance_1.info.log      ℹ️  信息日志
    ├── instance_2/
    │   └── ...
    └── predictions.jsonl            📊 合并结果
```

## 📄 轨迹文件内容

```json
{
  "trajectory": [                    // 执行步骤
    {
      "action": "search_file CVE",  // 执行的命令
      "observation": "Found 3...",   // 命令输出
      "response": "Let me search",   // LLM 完整响应
      "state": "{...}",              // 环境状态
      "thought": "Let me...",        // 推理过程
      "execution_time": 0.5          // 执行时间
    }
  ],
  "history": [                       // 完整对话
    {"role": "system", "content": "..."},
    {"role": "user", "content": "..."},
    {"role": "assistant", "content": "..."}
  ],
  "info": {                          // 元信息
    "exit_status": "submitted",
    "submission": "base64...",
    "model_stats": {
      "total_cost": 0.45,
      "api_calls": 23,
      "tokens_sent": 12543
    }
  }
}
```

## 🔄 保存时机

```
Agent.run()
    │
    ├─> step 1 ──> save_trajectory() ✅
    ├─> step 2 ──> save_trajectory() ✅
    ├─> step 3 ──> save_trajectory() ✅
    │   ...
    ├─> submit ──> save_trajectory() ✅
    └─> done ────> save_trajectory() ✅ (最终)
```

**保存频率**: 每个步骤后 + 提交后 + 最终

## 🛠️ 常用命令

### 查看轨迹

```bash
# 交互式检查
sweagent inspect trajectories/*/instance_0/instance_0.traj

# 重放轨迹
sweagent run-replay --trajectory path/to/instance.traj

# 查看 JSON 内容
cat trajectories/*/instance_0/instance_0.traj | jq .

# 查看日志
tail -f trajectories/*/instance_0/instance_0.debug.log
```

### 分析轨迹

```python
import json

# 读取轨迹
with open("instance.traj") as f:
    traj = json.load(f)

# 基本统计
print(f"Steps: {len(traj['trajectory'])}")
print(f"Cost: ${traj['info']['model_stats']['total_cost']}")
print(f"Calls: {traj['info']['model_stats']['api_calls']}")

# 提取所有动作
actions = [step['action'] for step in traj['trajectory']]
```

### 批量分析

```bash
# 查找所有轨迹
find trajectories/ -name "*.traj"

# 统计成功数量
grep -l '"submission"' trajectories/*/*.traj | wc -l

# 计算总成本
find trajectories/ -name "*.traj" -exec jq -r '.info.model_stats.total_cost' {} \; | awk '{s+=$1} END {print s}'
```

## 📊 典型轨迹示例

### PoC 模式轨迹

```
步骤数：35 步
文件大小：850 KB
执行时间：12 分钟
成本：$0.35
主要工具：search_file (12x), edit (8x), bash (15x)
结果：成功提交 PoC
```

### Patch 模式轨迹

```
步骤数：42 步
文件大小：1.2 MB
执行时间：15 分钟
成本：$0.48
主要工具：search_file (15x), edit (12x), bash (15x)
结果：成功生成补丁
```

## 🎯 使用场景

### 场景 1：调试失败

```bash
# 1. 查看最后的动作
jq '.trajectory[-5:]' instance.traj

# 2. 查看错误信息
grep -i "error" instance.debug.log

# 3. 重放到失败点
sweagent run-replay --trajectory instance.traj
```

### 场景 2：分析成功策略

```python
# 提取成功实例的动作序列
successful_actions = []
for traj_file in Path("trajectories").rglob("*.traj"):
    with open(traj_file) as f:
        traj = json.load(f)
    if traj['info'].get('submission'):
        actions = [s['action'].split()[0] for s in traj['trajectory']]
        successful_actions.append(actions)

# 分析常见模式
from collections import Counter
all_actions = [a for seq in successful_actions for a in seq]
print(Counter(all_actions).most_common(10))
```

### 场景 3：成本优化

```python
# 找出高成本步骤
high_cost_instances = []
for traj_file in Path("trajectories").rglob("*.traj"):
    with open(traj_file) as f:
        traj = json.load(f)
    cost = traj['info']['model_stats']['total_cost']
    steps = len(traj['trajectory'])
    if cost > 1.0:
        high_cost_instances.append({
            'file': traj_file.name,
            'cost': cost,
            'steps': steps,
            'cost_per_step': cost/steps
        })

# 排序并分析
high_cost_instances.sort(key=lambda x: x['cost'], reverse=True)
```

## ⚙️ 配置选项

### 输出目录

```bash
# 默认（自动生成）
./run_secb.sh poc -m deepseek -l :10
# → trajectories/deepseek__secb_poc__20250127_143022/

# 自定义
./run_secb.sh poc -m deepseek -l :10 --output_dir ./my_results/
# → my_results/

# 通过环境变量
export SWE_AGENT_OUTPUT_DIR=./my_results
```

### 跳过已完成实例

```bash
# 默认：跳过已有轨迹的实例
./run_secb.sh poc -m deepseek -l :10

# 强制重新运行
./run_secb.sh poc -m deepseek -l :10 --redo_existing=True
```

## 🔧 实用工具

### 轨迹统计脚本

```bash
#!/bin/bash
# traj_stats.sh - 轨迹统计工具

TRAJ_DIR=$1

echo "=== Trajectory Statistics ==="
echo "Total trajectories: $(find $TRAJ_DIR -name "*.traj" | wc -l)"
echo "Successful: $(grep -l '"submission"' $TRAJ_DIR/*/*.traj 2>/dev/null | wc -l)"
echo "Total cost: $(find $TRAJ_DIR -name "*.traj" -exec jq -r '.info.model_stats.total_cost // 0' {} \; | awk '{s+=$1} END {print "$" s}')"
echo "Total steps: $(find $TRAJ_DIR -name "*.traj" -exec jq '.trajectory | length' {} \; | awk '{s+=$1} END {print s}')"
```

使用：
```bash
chmod +x traj_stats.sh
./traj_stats.sh trajectories/deepseek__secb_poc__20250127/
```

### Python 分析库

```python
# traj_analyzer.py
import json
from pathlib import Path
from dataclasses import dataclass
from typing import List

@dataclass
class TrajectoryStats:
    instance_id: str
    steps: int
    cost: float
    api_calls: int
    success: bool
    execution_time: float

class TrajectoryAnalyzer:
    def __init__(self, traj_dir: str):
        self.traj_dir = Path(traj_dir)

    def load_all(self) -> List[TrajectoryStats]:
        stats = []
        for traj_file in self.traj_dir.rglob("*.traj"):
            with open(traj_file) as f:
                traj = json.load(f)

            total_time = sum(s['execution_time'] for s in traj['trajectory'])
            stats.append(TrajectoryStats(
                instance_id=traj_file.parent.name,
                steps=len(traj['trajectory']),
                cost=traj['info']['model_stats']['total_cost'],
                api_calls=traj['info']['model_stats']['api_calls'],
                success=bool(traj['info'].get('submission')),
                execution_time=total_time
            ))
        return stats

    def summary(self):
        stats = self.load_all()
        print(f"Total Instances: {len(stats)}")
        print(f"Success Rate: {sum(s.success for s in stats)/len(stats)*100:.1f}%")
        print(f"Total Cost: ${sum(s.cost for s in stats):.2f}")
        print(f"Avg Steps: {sum(s.steps for s in stats)/len(stats):.1f}")
        print(f"Avg Time: {sum(s.execution_time for s in stats)/len(stats)/60:.1f} min")

# 使用
analyzer = TrajectoryAnalyzer("trajectories/deepseek__secb_poc__20250127/")
analyzer.summary()
```

## 📚 延伸阅读

- 📖 **详细文档**: `轨迹保存机制.md`（14000+ 字完整分析）
- 🚀 **快速参考**: `快速参考手册.md`（常用命令速查）
- 🔍 **工作流分析**: `完整工作流分析.md`（端到端流程）

## 💡 关键要点

1. ✅ **自动保存**：无需手动干预，完全自动化
2. 📝 **完整记录**：动作、观察、思考、对话全记录
3. 🔄 **可重放**：支持完整重放调试
4. 📊 **易分析**：JSON 格式，易于编程处理
5. 💾 **多实例**：批量运行每个独立保存
6. 🎯 **多用途**：调试、分析、训练、演示

---

**轨迹文件是理解和优化 SWE-agent 的关键！** 充分利用它们！
